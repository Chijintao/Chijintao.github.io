<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="池劲涛的博客">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="池劲涛的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="池劲涛">
<meta property="article:tag" content="Python Linux Vue">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/6/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>池劲涛的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">池劲涛的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="池劲涛"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">池劲涛</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">62</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/11/12/%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="池劲涛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="池劲涛的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/12/%E6%A8%A1%E5%9D%97/" class="post-title-link" itemprop="url">模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-12 07:20:25" itemprop="dateCreated datePublished" datetime="2018-11-12T07:20:25+08:00">2018-11-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-12-01 12:22:34" itemprop="dateModified" datetime="2018-12-01T12:22:34+08:00">2018-12-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Python系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h1><ul>
<li>模块介绍</li>
<li>模块的使用</li>
</ul>
<h1 id="内容详细"><a href="#内容详细" class="headerlink" title="内容详细"></a>内容详细</h1><h2 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h2><p><strong>在Python中，一个py文件就是一个模块，文件名为xxx.py模块名则是xxx,导入模块可以引用模块中已经写好的功能。如果把开发程序比喻成制造一台电脑，编写模块就像是在制造电脑的零部件，准备好零部件后，剩下的工作就是按照逻辑把它们组装到一起。</strong></p>
<p><strong>将程序模块化会使得程序的组织结构清晰，维护起来更加方便。比起直接开发一个完整的程序，单独开发一个小的模块也会更加简单，并且程序中的模块与电脑中的零部件稍微不同的是：程序中的模块可以被重复使用。所以总结下来，使用模块既保证了代码的重用性，又增强了程序的结构性和可维护性。另外除了自定义模块外，我们还可以导入使用内置或第三方模块提供的现成功能，这种“拿来主义”极大地提高了程序员的开发效率。</strong></p>
<h2 id="模块的使用"><a href="#模块的使用" class="headerlink" title="模块的使用"></a>模块的使用</h2><h3 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件名：foo.py</span></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>():</span></span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;from the func&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">想要在另一个py文件中引用foo.py中的功能，需要使用<span class="keyword">import</span> foo，首次导入模块会做三件事：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> 执行源文件代码</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 产生一个新的名称空间用于存放源文件执行过程中产生的名字</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> 在当前执行文件所在的名称空间中得到一个名字foo，该名字指向新创建的模块名称空间，若要引用模块名称空间中的名字，需要加上该前缀，如：</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> foo <span class="comment"># 导入模块foo</span></span><br><span class="line">a = foo.x <span class="comment"># 引用模块foo中变量x的值赋值给当前名称空间中的名字a</span></span><br><span class="line">foo.get() <span class="comment"># 调用模块foo中的get函数</span></span><br><span class="line">foo.change() <span class="comment"># 调用模块foo中的change函数</span></span><br><span class="line">obj = foo.Foo() <span class="comment"># 调用模块foo的类Foo来实例化，进一步可以执行obj.func()</span></span><br><span class="line"></span><br><span class="line">加上foo.作为前缀，就相当于指名道姓地说明要引用foo名称空间中的名字，所以肯定不会与当前执行文件所在名称空间中的名字相冲突，并且若当前执行文件的名称空间中存在x，执行foo.get()或者foo.change()操作的都是源文件中的全局变量x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强调：第一次导入模块已经将其加载到内存空间了，之后的重复导入会直接引用内存中已存在的模块，不会重复执行文件，通过import sys，打印sys.modules的值可以看到内存中已经加载的模块名</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line"><span class="comment">#1、在Python中模块也属于第一类对象，可以进行赋值、以数据形式传递以及作为容器类型的元素等操作。</span></span><br><span class="line"><span class="comment">#2、模块名应该遵循小写形式，标准库从python2过渡到python3做出了很多这类调整，比如ConfigParser、Queue、SocketServer全更新为纯小写形式。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">用<span class="keyword">import</span>语句导入多个模块，可以写多行<span class="keyword">import</span>语句</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> module1</span><br><span class="line"><span class="keyword">import</span> module2</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">import</span> moduleN</span><br><span class="line">还可以在一行导入，用逗号分隔开不同的模块</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> module1,module2,...,moduleN</span><br><span class="line">但其实第一种形式更为规范，可读性更强，推荐使用，而且我们导入的模块中可能包含有python内置的模块、第三方的模块、自定义的模块，为了便于明显地区分它们，我们通常在文件的开头导入模块，并且分类导入，一类模块的导入与另外一类的导入用空行隔开，不同类别的导入顺序如下：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> python内置模块</span><br><span class="line"><span class="number">2.</span> 第三方模块</span><br><span class="line"><span class="number">3.</span> 程序员自定义模块</span><br><span class="line">当然，我们也可以在函数内导入模块，对比在文件开头导入模块属于全局作用域，在函数内导入的模块则属于局部的作用域。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="from-import语句"><a href="#from-import语句" class="headerlink" title="from import语句"></a>from import语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span>...<span class="keyword">import</span>...与<span class="keyword">import</span>语句基本一致，唯一不同的是：使用<span class="keyword">import</span> foo导入模块后，引用模块中的名字都需要加上foo.作为前缀，而使用<span class="keyword">from</span> foo <span class="keyword">import</span> x,get,change,Foo则可以在当前执行文件中直接引用模块foo中的名字，如下</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> x,get,change <span class="comment">#将模块foo中的x和get导入到当前名称空间</span></span><br><span class="line">a=x <span class="comment">#直接使用模块foo中的x赋值给a</span></span><br><span class="line">get() <span class="comment">#直接执行foo中的get函数</span></span><br><span class="line">change() <span class="comment">#即便是当前有重名的x，修改的仍然是源文件中的x</span></span><br><span class="line">无需加前缀的好处是使得我们的代码更加简洁，坏处则是容易与当前名称空间中的名字冲突，如果当前名称空间存在相同的名字，则后定义的名字会覆盖之前定义的名字。</span><br><span class="line"></span><br><span class="line">另外<span class="keyword">from</span>语句支持<span class="keyword">from</span> foo <span class="keyword">import</span> 语法，代表将foo中所有的名字都导入到当前位置</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> * <span class="comment">#把foo中所有的名字都导入到当前执行文件的名称空间中，在当前位置直接可以使用这些名字</span></span><br><span class="line"></span><br><span class="line">a=x</span><br><span class="line">get()</span><br><span class="line">change()</span><br><span class="line">obj=Foo()</span><br><span class="line">如果我们需要引用模块中的名字过多的话，可以采用上述的导入形式来达到节省代码量的效果，但是需要强调的一点是：只能在模块最顶层使用的方式导入，在函数内则非法，并且的方式会带来一种副作用，即我们无法搞清楚究竟从源文件中导入了哪些名字到当前位置，这极有可能与当前位置的名字产生冲突。模块的编写者可以在自己的文件中定义__all__变量用来控制*代表的意思</span><br><span class="line"></span><br><span class="line"><span class="comment">#foo.py</span></span><br><span class="line">__all__=[<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;get&#x27;</span>] <span class="comment">#该列表中所有的元素必须是字符串类型，每个元素对应foo.py中的一个名字</span></span><br><span class="line">x=<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>():</span></span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    x=<span class="number">0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&#x27;from the func&#x27;</span>)</span><br><span class="line">这样我们在另外一个文件中使用*导入时，就只能导入__all__定义的名字了</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> * <span class="comment">#此时的*只代表x和get</span></span><br><span class="line"></span><br><span class="line">x <span class="comment">#可用</span></span><br><span class="line">get() <span class="comment">#可用</span></span><br><span class="line">change() <span class="comment">#不可用</span></span><br><span class="line">Foo() <span class="comment">#不可用</span></span><br></pre></td></tr></table></figure>

<h3 id="其他导入语法-as"><a href="#其他导入语法-as" class="headerlink" title="其他导入语法(as)"></a>其他导入语法(as)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">我们还可以在当前位置为导入的模块起一个别名</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">as</span> f <span class="comment">#为导入的模块foo在当前位置起别名f，以后再使用时就用这个别名f</span></span><br><span class="line">f.x</span><br><span class="line">f.get()</span><br><span class="line">还可以为导入的一个名字起别名</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> get <span class="keyword">as</span> get_x</span><br><span class="line">get_x()</span><br><span class="line">通常在被导入的名字过长时采用起别名的方式来精简代码，另外为被导入的名字起别名可以很好地避免与当前名字发生冲突，还有很重要的一点就是：可以保持调用方式的一致性，例如我们有两个模块json和pickle同时实现了load方法，作用是从一个打开的文件中解析出结构化的数据，但解析的格式不同，可以用下述代码有选择性地加载不同的模块</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> data_format == <span class="string">&#x27;json&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> json <span class="keyword">as</span> serialize <span class="comment">#如果数据格式是json，那么导入json模块并命名为serialize</span></span><br><span class="line"><span class="keyword">elif</span> data_format == <span class="string">&#x27;pickle&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> pickle <span class="keyword">as</span> serialize <span class="comment">#如果数据格式是pickle，那么导入pickle模块并命名为serialize</span></span><br><span class="line"></span><br><span class="line">data=serialize.load(fn) <span class="comment">#最终调用的方式是一致的</span></span><br></pre></td></tr></table></figure>

<h3 id="循环导入问题"><a href="#循环导入问题" class="headerlink" title="循环导入问题"></a>循环导入问题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">循环导入问题指的是在一个模块加载/导入的过程中导入另外一个模块，而在另外一个模块中又返回来导入第一个模块中的名字，由于第一个模块尚未加载完毕，所以引用失败、抛出异常，究其根源就是在python中，同一个模块只会在第一次导入时执行其内部代码，再次导入该模块时，即便是该模块尚未完全加载完毕也不会去重复执行内部代码</span><br><span class="line"></span><br><span class="line">我们以下述文件为例，来详细分析循环/嵌套导入出现异常的原因以及解决的方案</span><br><span class="line"></span><br><span class="line">m1.py</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;正在导入m1&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> m2 <span class="keyword">import</span> y</span><br><span class="line"></span><br><span class="line">x=<span class="string">&#x27;m1&#x27;</span></span><br><span class="line">m2.py</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;正在导入m2&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> m1 <span class="keyword">import</span> x</span><br><span class="line"></span><br><span class="line">y=<span class="string">&#x27;m2&#x27;</span></span><br><span class="line">run.py</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> m1</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">测试一</span><br><span class="line"></span><br><span class="line"><span class="comment">#1、执行run.py会抛出异常</span></span><br><span class="line">正在导入m1</span><br><span class="line">正在导入m2</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/linhaifeng/PycharmProjects/pro01/1 aaaa练习目录/aa.py&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">import</span> m1</span><br><span class="line">  File <span class="string">&quot;/Users/linhaifeng/PycharmProjects/pro01/1 aaaa练习目录/m1.py&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> m2 <span class="keyword">import</span> y</span><br><span class="line">  File <span class="string">&quot;/Users/linhaifeng/PycharmProjects/pro01/1 aaaa练习目录/m2.py&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> m1 <span class="keyword">import</span> x</span><br><span class="line">ImportError: cannot <span class="keyword">import</span> name <span class="string">&#x27;x&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2、分析</span></span><br><span class="line">先执行run.py---&gt;执行<span class="keyword">import</span> m1，开始导入m1并运行其内部代码---&gt;打印内容<span class="string">&quot;正在导入m1&quot;</span></span><br><span class="line">---&gt;执行<span class="keyword">from</span> m2 <span class="keyword">import</span> y 开始导入m2并运行其内部代码---&gt;打印内容“正在导入m2”---&gt;执行<span class="keyword">from</span> m1 <span class="keyword">import</span> x,由于m1已经被导入过了，所以不会重新导入，所以直接去m1中拿x，然而x此时并没有存在于m1中，所以报错</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">测试二</span><br><span class="line"></span><br><span class="line"><span class="comment">#1、执行文件不等于导入文件，比如执行m1.py不等于导入了m1</span></span><br><span class="line">直接执行m1.py抛出异常</span><br><span class="line">正在导入m1</span><br><span class="line">正在导入m2</span><br><span class="line">正在导入m1</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/linhaifeng/PycharmProjects/pro01/1 aaaa练习目录/m1.py&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> m2 <span class="keyword">import</span> y</span><br><span class="line">  File <span class="string">&quot;/Users/linhaifeng/PycharmProjects/pro01/1 aaaa练习目录/m2.py&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> m1 <span class="keyword">import</span> x</span><br><span class="line">  File <span class="string">&quot;/Users/linhaifeng/PycharmProjects/pro01/1 aaaa练习目录/m1.py&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">from</span> m2 <span class="keyword">import</span> y</span><br><span class="line">ImportError: cannot <span class="keyword">import</span> name <span class="string">&#x27;y&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#2、分析</span></span><br><span class="line">执行m1.py，打印“正在导入m1”，执行<span class="keyword">from</span> m2 <span class="keyword">import</span> y ，导入m2进而执行m2.py内部代码---&gt;打印<span class="string">&quot;正在导入m2&quot;</span>，执行<span class="keyword">from</span> m1 <span class="keyword">import</span> x，此时m1是第一次被导入，执行m1.py并不等于导入了m1，于是开始导入m1并执行其内部代码---&gt;打印<span class="string">&quot;正在导入m1&quot;</span>，执行<span class="keyword">from</span> m1 <span class="keyword">import</span> y，由于m1已经被导入过了，所以无需继续导入而直接问m2要y，然而y此时并没有存在于m2中所以报错</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">解决方案</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方案一：导入语句放到最后，保证在导入时，所有名字都已经加载过</span></span><br><span class="line"><span class="comment"># 文件：m1.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;正在导入m1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">x=<span class="string">&#x27;m1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> m2 <span class="keyword">import</span> y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件：m2.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;正在导入m2&#x27;</span>)</span><br><span class="line">y=<span class="string">&#x27;m2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> m1 <span class="keyword">import</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件：run.py内容如下，执行该文件，可以正常使用</span></span><br><span class="line"><span class="keyword">import</span> m1</span><br><span class="line"><span class="built_in">print</span>(m1.x)</span><br><span class="line"><span class="built_in">print</span>(m1.y)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 方案二：导入语句放到函数中，只有在调用函数时才会执行其内部代码</span></span><br><span class="line"><span class="comment"># 文件：m1.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;正在导入m1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    <span class="keyword">from</span> m2 <span class="keyword">import</span> y</span><br><span class="line">    <span class="built_in">print</span>(x,y)</span><br><span class="line"></span><br><span class="line">x = <span class="string">&#x27;m1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件：m2.py</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;正在导入m2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span></span><br><span class="line">    <span class="keyword">from</span> m1 <span class="keyword">import</span> x</span><br><span class="line">    <span class="built_in">print</span>(x,y)</span><br><span class="line"></span><br><span class="line">y = <span class="string">&#x27;m2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件：run.py内容如下，执行该文件，可以正常使用</span></span><br><span class="line"><span class="keyword">import</span> m1</span><br><span class="line"></span><br><span class="line">m1.f1()</span><br><span class="line">注意：循环导入问题大多数情况是因为程序设计失误导致，上述解决方案也只是在烂设计之上的无奈之举，在我们的程序中应该尽量避免出现循环/嵌套导入，如果多个模块确实都需要共享某些数据，可以将共享的数据集中存放到某一个地方，然后进行导入</span><br></pre></td></tr></table></figure>

<h3 id="搜索模块的路径与优先级"><a href="#搜索模块的路径与优先级" class="headerlink" title="搜索模块的路径与优先级"></a>搜索模块的路径与优先级</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">模块其实分为四个通用类别，分别是：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、使用纯Python代码编写的py文件</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、包含一系列模块的包</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、使用C编写并链接到Python解释器中的内置模块</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、使用C或C++编译的扩展模块</span><br><span class="line"></span><br><span class="line">在导入一个模块时，如果该模块已加载到内存中，则直接引用，否则会优先查找内置模块，然后按照从左到右的顺序依次检索sys.path中定义的路径，直到找模块对应的文件为止，否则抛出异常。sys.path也被称为模块的搜索路径，它是一个列表类型</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path</span><br><span class="line">[<span class="string">&#x27;&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.5/lib/python35.zip&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5&#x27;</span>,</span><br><span class="line">...,</span><br><span class="line"><span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">列表中的每个元素其实都可以当作一个目录来看：在列表中会发现有.<span class="built_in">zip</span>或.egg结尾的文件，二者是不同形式的压缩文件，事实上Python确实支持从一个压缩文件中导入模块，我们也只需要把它们都当成目录去看即可。</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">sys.path中的第一个路径通常为空，代表执行文件所在的路径，所以在被导入模块与执行文件在同一目录下时肯定是可以正常导入的，而针对被导入的模块与执行文件在不同路径下的情况，为了确保模块对应的源文件仍可以被找到，需要将源文件foo.py所在的路径添加到sys.path中，假设foo.py所在的路径为/pythoner/projects/</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">r&#x27;/pythoner/projects/&#x27;</span>) <span class="comment">#也可以使用sys.path.insert(……)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> foo <span class="comment">#无论foo.py在何处,我们都可以导入它了</span></span><br></pre></td></tr></table></figure>

<h3 id="区分py文件的两种用途"><a href="#区分py文件的两种用途" class="headerlink" title="区分py文件的两种用途"></a>区分py文件的两种用途</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">一个Python文件有两种用途，一种被当主程序/脚本执行，另一种被当模块导入，为了区别同一个文件的不同用途，每个py文件都内置了__name__变量，该变量在py文件被当做脚本执行时赋值为“__main__”,在py文件被当做模块导入时赋值为模块名</span><br><span class="line"></span><br><span class="line">作为模块foo.py的开发者，可以在文件末尾基于__name__在不同应用场景下值的不同来控制文件执行不同的逻辑</span><br><span class="line"></span><br><span class="line"><span class="comment">#foo.py</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    foo.py被当做脚本执行时运行的代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    foo.py被当做模块导入时运行的代码</span><br></pre></td></tr></table></figure>

<p><strong>通常我们会在if的子代码块中编写针对模块功能的测试代码，这样foo.py在被当做脚本运行时，就会执行测试代码，而被当做模块导入时则不用执行测试代码。</strong></p>
<h3 id="编写一个规范的模块"><a href="#编写一个规范的模块" class="headerlink" title="编写一个规范的模块"></a>编写一个规范的模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">我们在编写py文件时，需要时刻提醒自己，该文件既是给自己用的，也有可能会被其他人使用，因而代码的可读性与易维护性显得十分重要，为此我们在编写一个模块时最好按照统一的规范去编写，如下:</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python #通常只在类unix环境有效,作用是可以使用脚本名来执行，而无需直接调用解释器。</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;The module is used to...&quot;</span> <span class="comment">#模块的文档描述</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys <span class="comment">#导入模块</span></span><br><span class="line"></span><br><span class="line">x=<span class="number">1</span> <span class="comment">#定义全局变量,如果非必须,则最好使用局部变量,这样可以提高代码的易维护性,并且可以节省内存提高性能</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span> <span class="comment">#定义类,并写好类的注释</span></span><br><span class="line">    <span class="string">&#x27;Class Foo is used to...&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span> <span class="comment">#定义函数,并写好函数的注释</span></span><br><span class="line">    <span class="string">&#x27;Function test is used to…&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>: <span class="comment">#主程序</span></span><br><span class="line">    test() <span class="comment">#在被当做脚本执行时,执行此处的代码 </span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/11/12/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="池劲涛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="池劲涛的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/12/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">流程控制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-12 07:20:25" itemprop="dateCreated datePublished" datetime="2018-11-12T07:20:25+08:00">2018-11-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-12-01 12:22:34" itemprop="dateModified" datetime="2018-12-01T12:22:34+08:00">2018-12-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Python系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h1><h2 id="什么是分支结构"><a href="#什么是分支结构" class="headerlink" title="什么是分支结构"></a>什么是分支结构</h2><p><strong>分支结构就是根据条件判断的真假去执行不同分支对应的子代码</strong></p>
<h2 id="为什么要用分支结构"><a href="#为什么要用分支结构" class="headerlink" title="为什么要用分支结构"></a>为什么要用分支结构</h2><p><strong>人类某些时候需要根据条件来决定做什么事情，比如：’如果今天下雨，就带伞’</strong></p>
<p><strong>所以程序中必须有相应的机制来控制计算机具备的人的这种判断能力</strong></p>
<h2 id="如何使用分支结构"><a href="#如何使用分支结构" class="headerlink" title="如何使用分支结构"></a>如何使用分支结构</h2><h3 id="if语法"><a href="#if语法" class="headerlink" title="if语法"></a>if语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span>:   <span class="comment"># 如果条件1的结果为True，就依次执行：代码1、代码2，......</span></span><br><span class="line">  　代码<span class="number">1</span></span><br><span class="line">    代码<span class="number">2</span></span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">2</span>: <span class="comment"># 如果条件2的结果为True，就依次执行：代码3、代码4，......</span></span><br><span class="line">  　代码<span class="number">3</span></span><br><span class="line">    代码<span class="number">4</span></span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">3</span>: <span class="comment"># 如果条件3的结果为True，就依次执行：代码5、代码6，......</span></span><br><span class="line">  　代码<span class="number">5</span></span><br><span class="line">    代码<span class="number">6</span></span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">else</span>:　　   <span class="comment"># 其它情况，就依次执行：代码7、代码8，......</span></span><br><span class="line">    代码<span class="number">7</span></span><br><span class="line">    代码<span class="number">8</span></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 注意：</span></span><br><span class="line">        <span class="number">1</span> python用相同缩进(<span class="number">4</span>个空格表示一个缩进)来标识一组代码块，用一组代码会自上而下依次运行</span><br><span class="line">        </span><br><span class="line">        <span class="number">2</span> 条件可以使任意表达式，但执行结果必须为布尔类型</span><br><span class="line">            <span class="comment"># 在if判断中所有的数据类型也都会自动转换成布尔类型</span></span><br><span class="line">            <span class="number">2.1</span> <span class="literal">None</span>， <span class="number">0</span>， 空(空字符串， 空列表， 空字典等)三种情况下转换成的布尔值为<span class="literal">False</span></span><br><span class="line">            <span class="number">2.2</span> 其余均为<span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="if应用案例"><a href="#if应用案例" class="headerlink" title="if应用案例"></a>if应用案例</h3><p>案例1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果：女人的年龄&gt;<span class="number">30</span>岁，那么：叫阿姨</span><br><span class="line"></span><br><span class="line">age_of_girl=<span class="number">31</span></span><br><span class="line"><span class="keyword">if</span> age_of_girl &gt; <span class="number">30</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;阿姨好&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>案例2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果：女人的年龄&gt;<span class="number">30</span>岁，那么：叫阿姨，否则：叫小姐</span><br><span class="line"></span><br><span class="line">age_of_girl=<span class="number">18</span></span><br><span class="line"><span class="keyword">if</span> age_of_girl &gt; <span class="number">30</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;阿姨好&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;小姐好&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>案例3：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如果：女人的年龄&gt;=<span class="number">18</span>并且&lt;<span class="number">22</span>岁并且身高&gt;<span class="number">170</span>并且体重&lt;<span class="number">100</span>并且是漂亮的，那么：表白，否则：叫阿姨**</span><br><span class="line"></span><br><span class="line">age_of_girl=<span class="number">18</span></span><br><span class="line">height=<span class="number">171</span></span><br><span class="line">weight=<span class="number">99</span></span><br><span class="line">is_pretty=<span class="literal">True</span></span><br><span class="line"><span class="keyword">if</span> age_of_girl &gt;= <span class="number">18</span> <span class="keyword">and</span> age_of_girl &lt; <span class="number">22</span> <span class="keyword">and</span> height &gt; <span class="number">170</span> <span class="keyword">and</span> weight &lt; <span class="number">100</span> <span class="keyword">and</span> is_pretty == <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;表白...&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;阿姨好&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>案例4：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">如果：成绩&gt;=<span class="number">90</span>，那么：优秀</span><br><span class="line"></span><br><span class="line">如果成绩&gt;=<span class="number">80</span>且&lt;<span class="number">90</span>,那么：良好</span><br><span class="line"></span><br><span class="line">如果成绩&gt;=<span class="number">70</span>且&lt;<span class="number">80</span>,那么：普通</span><br><span class="line"></span><br><span class="line">其他情况：很差</span><br><span class="line"></span><br><span class="line">score=<span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>)</span><br><span class="line">score=<span class="built_in">int</span>(score)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;优秀&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">80</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;良好&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">70</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;普通&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;很差&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>案例5：if嵌套</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在表白的基础上继续：</span></span><br><span class="line"><span class="comment">#如果表白成功，那么：在一起</span></span><br><span class="line"><span class="comment">#否则：打印。。。</span></span><br><span class="line"></span><br><span class="line">age_of_girl=<span class="number">18</span></span><br><span class="line">height=<span class="number">171</span></span><br><span class="line">weight=<span class="number">99</span></span><br><span class="line">is_pretty=<span class="literal">True</span></span><br><span class="line">success=<span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> age_of_girl &gt;= <span class="number">18</span> <span class="keyword">and</span> age_of_girl &lt; <span class="number">22</span> <span class="keyword">and</span> height &gt; <span class="number">170</span> <span class="keyword">and</span> weight &lt; <span class="number">100</span> <span class="keyword">and</span> is_pretty == <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> success:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;表白成功,在一起&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;什么爱情不爱情的,爱nmlgb的爱情,爱nmlg啊...&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;阿姨好&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">练习<span class="number">1</span>: 登陆功能</span><br><span class="line"></span><br><span class="line">name=<span class="built_in">input</span>(<span class="string">&#x27;请输入用户名字：&#x27;</span>).strip()</span><br><span class="line">password=<span class="built_in">input</span>(<span class="string">&#x27;请输入密码：&#x27;</span>).strip()</span><br><span class="line"><span class="keyword">if</span> name == <span class="string">&#x27;tony&#x27;</span> <span class="keyword">and</span> password == <span class="string">&#x27;123&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;tony login success&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;用户名或密码错误&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">练习<span class="number">2</span>：</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据用户输入内容打印其权限</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">egon --&gt; 超级管理员</span></span><br><span class="line"><span class="string">tom  --&gt; 普通管理员</span></span><br><span class="line"><span class="string">jack,rain --&gt; 业务主管</span></span><br><span class="line"><span class="string">其他 --&gt; 普通用户</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">name=<span class="built_in">input</span>(<span class="string">&#x27;请输入用户名字：&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">&#x27;egon&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;超级管理员&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> name == <span class="string">&#x27;tom&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;普通管理员&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> name == <span class="string">&#x27;jack&#x27;</span> <span class="keyword">or</span> name == <span class="string">&#x27;rain&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;业务主管&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;普通用户&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h1><h2 id="什么是循环结构？"><a href="#什么是循环结构？" class="headerlink" title="什么是循环结构？"></a>什么是循环结构？</h2><p><strong>循环结构就是重复执行某段代码块</strong></p>
<h2 id="为什么要用循环结构？"><a href="#为什么要用循环结构？" class="headerlink" title="为什么要用循环结构？"></a>为什么要用循环结构？</h2><p><img src="https://pic4.zhimg.com/80/v2-f174b482ecf2583633bd31e3a13f8e8b_720w.jpg" alt="img"></p>
<p>​        <strong>人类某些时候需要重复做某些事情 所以程序中必须有相应的机制来控制计算机具备人的这种循环做事的能力</strong></p>
<h2 id="如何使用循环结构？"><a href="#如何使用循环结构？" class="headerlink" title="如何使用循环结构？"></a>如何使用循环结构？</h2><h3 id="while循环语法"><a href="#while循环语法" class="headerlink" title="while循环语法"></a>while循环语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">python中有<span class="keyword">while</span>和<span class="keyword">for</span>两种循环机制，其中<span class="keyword">while</span>循环称之为条件循环，语法如下</span><br><span class="line">  	 <span class="keyword">while</span> 条件：</span><br><span class="line">      	代码<span class="number">1</span></span><br><span class="line">          代码<span class="number">2</span></span><br><span class="line">          代码<span class="number">3</span></span><br><span class="line">     <span class="comment"># while的运行步骤</span></span><br><span class="line">  		<span class="number">1</span> 如果条件为真，那么依次执行：代码<span class="number">1</span>， 代码<span class="number">2</span>， 代码<span class="number">3.</span>..</span><br><span class="line">      	<span class="number">2</span> 执行完毕后再次判断条件，如果条件为<span class="literal">True</span>则代码再次执行：代码<span class="number">1</span>， 代码<span class="number">2</span>， 代码<span class="number">3.</span>..</span><br><span class="line">            如果条件为<span class="literal">False</span>，则循环终止</span><br></pre></td></tr></table></figure>

<p><img src="https://pic3.zhimg.com/80/v2-6f56fdbd7d92dd2a7ce02573d950136a_720w.jpg" alt="img"></p>
<h3 id="while循环应用案例"><a href="#while循环应用案例" class="headerlink" title="while循环应用案例"></a>while循环应用案例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">案例一：<span class="keyword">while</span>循环的基本使用</span><br><span class="line">用户认证程序</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 用户认证程序的基本逻辑就是接收用户输入的用户名密码然后与程序中存放的用户名密码进行判断，判断成功则登陆成功，判断失败则输出账号或密码错误</span></span><br><span class="line">    </span><br><span class="line">    username = <span class="string">&quot;jason&quot;</span></span><br><span class="line">password = <span class="string">&quot;123&quot;</span></span><br><span class="line"></span><br><span class="line">inp_name =  <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line">inp_pwd =  <span class="built_in">input</span>(<span class="string">&quot;请输入密码：&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> inp_name == username <span class="keyword">and</span> inp_pwd == password:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;登陆成功&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;输入的用户名或密码错误！&quot;</span>)</span><br><span class="line"><span class="comment">#通常认证失败的情况下，会要求用户重新输入用户名和密码进行验证，如果我们想给用户三次试错机会，本质就是将上述代码重复运行三遍，你总不会想着把代码复制3次吧。。。。</span></span><br><span class="line">username = <span class="string">&quot;jason&quot;</span></span><br><span class="line">password = <span class="string">&quot;123&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次验证</span></span><br><span class="line">inp_name =  <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line">inp_pwd =  <span class="built_in">input</span>(<span class="string">&quot;请输入密码：&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> inp_name == username <span class="keyword">and</span> inp_pwd == password:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;登陆成功&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;输入的用户名或密码错误！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二次验证</span></span><br><span class="line">inp_name =  <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line">inp_pwd =  <span class="built_in">input</span>(<span class="string">&quot;请输入密码：&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> inp_name == username <span class="keyword">and</span> inp_pwd == password:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;登陆成功&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;输入的用户名或密码错误！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三次验证</span></span><br><span class="line">inp_name =  <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line">inp_pwd =  <span class="built_in">input</span>(<span class="string">&quot;请输入密码：&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> inp_name == username <span class="keyword">and</span> inp_pwd == password:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;登陆成功&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;输入的用户名或密码错误！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#即使是小白的你，也觉得的太low了是不是，以后要修改功能还得修改3次，因此记住，写重复的代码是程序员最不耻的行为。</span></span><br><span class="line"><span class="comment">#那么如何做到不用写重复代码又能让程序重复一段代码多次呢？ 循环语句就派上用场啦（使用while循环实现）</span></span><br><span class="line"></span><br><span class="line">username = <span class="string">&quot;jason&quot;</span></span><br><span class="line">password = <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="comment"># 记录错误验证的次数</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">3</span>:</span><br><span class="line">    inp_name = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line">    inp_pwd = <span class="built_in">input</span>(<span class="string">&quot;请输入密码：&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> inp_name == username <span class="keyword">and</span> inp_pwd == password:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;登陆成功&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;输入的用户名或密码错误！&quot;</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">案例二：<span class="keyword">while</span>+<span class="keyword">break</span>的使用</span><br><span class="line"></span><br><span class="line">使用了<span class="keyword">while</span>循环后，代码确实精简多了，但问题是用户输入正确的用户名密码以后无法结束循环，那如何结束掉一个循环呢？这就需要用到<span class="keyword">break</span>了！</span><br><span class="line">username = <span class="string">&quot;jason&quot;</span></span><br><span class="line">password = <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="comment"># 记录错误验证的次数</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">3</span>:</span><br><span class="line">    inp_name = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line">    inp_pwd = <span class="built_in">input</span>(<span class="string">&quot;请输入密码：&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> inp_name == username <span class="keyword">and</span> inp_pwd == password:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;登陆成功&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span> <span class="comment"># 用于结束本层循环</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;输入的用户名或密码错误！&quot;</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">案例三：<span class="keyword">while</span>循环嵌套+<span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">如果<span class="keyword">while</span>循环嵌套了很多层，要想退出每一层循环则需要在每一层循环都有一个<span class="keyword">break</span></span><br><span class="line">username = <span class="string">&quot;jason&quot;</span></span><br><span class="line">password = <span class="string">&quot;123&quot;</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">3</span>:  <span class="comment"># 第一层循环</span></span><br><span class="line">    inp_name = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line">    inp_pwd = <span class="built_in">input</span>(<span class="string">&quot;请输入密码：&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> inp_name == username <span class="keyword">and</span> inp_pwd == password:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;登陆成功&quot;</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 第二层循环</span></span><br><span class="line">            cmd = <span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> cmd == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># 用于结束本层循环，即第二层循环</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;run &lt;%s&gt;&#x27;</span> % cmd)</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 用于结束本层循环，即第一层循环</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;输入的用户名或密码错误！&quot;</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">案例四：<span class="keyword">while</span>循环嵌套+tag的使用</span><br><span class="line"></span><br><span class="line">针对嵌套多层的<span class="keyword">while</span>循环，如果我们的目的很明确就是要在某一层直接退出所有层的循环，其实有一个窍门，就让所有<span class="keyword">while</span>循环的条件都用同一个变量，该变量的初始值为<span class="literal">True</span>，一旦在某一层将该变量的值改成<span class="literal">False</span>，则所有层的循环都结束</span><br><span class="line">username = <span class="string">&quot;jason&quot;</span></span><br><span class="line">password = <span class="string">&quot;123&quot;</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">tag = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> tag: </span><br><span class="line">    inp_name = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)</span><br><span class="line">    inp_pwd = <span class="built_in">input</span>(<span class="string">&quot;请输入密码：&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> inp_name == username <span class="keyword">and</span> inp_pwd == password:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;登陆成功&quot;</span>)</span><br><span class="line">        <span class="keyword">while</span> tag:  </span><br><span class="line">            cmd = <span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> cmd == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">                tag = <span class="literal">False</span>  <span class="comment"># tag变为False， 所有while循环的条件都变为False </span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;run &lt;%s&gt;&#x27;</span> % cmd)</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 用于结束本层循环，即第一层循环</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;输入的用户名或密码错误！&quot;</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">案例五：<span class="keyword">while</span>+<span class="keyword">continue</span>的使用</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>代表结束本层循环，而<span class="keyword">continue</span>则用于结束本次循环，直接进入下一次循环</span><br><span class="line"><span class="comment"># 打印1到10之间，除7以外的所有数字</span></span><br><span class="line">number=<span class="number">11</span></span><br><span class="line"><span class="keyword">while</span> number&gt;<span class="number">1</span>:</span><br><span class="line">    number -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> number==<span class="number">7</span>:</span><br><span class="line">        <span class="keyword">continue</span> <span class="comment"># 结束掉本次循环，即本次循环continue之后的代码都不会运行了，而是直接进入下一次循环</span></span><br><span class="line">    <span class="built_in">print</span>(number)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">案例五：<span class="keyword">while</span>+<span class="keyword">else</span>的使用</span><br><span class="line"></span><br><span class="line">在<span class="keyword">while</span>循环的后面，我们可以跟<span class="keyword">else</span>语句，当<span class="keyword">while</span> 循环正常执行完并且中间没有被<span class="keyword">break</span> 中止的话，就会执行<span class="keyword">else</span>后面的语句，所以我们可以用<span class="keyword">else</span>来验证，循环是否正常结束</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt;= <span class="number">5</span> :</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Loop&quot;</span>,count)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;循环正常执行完啦&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----out of while loop ------&quot;</span>)</span><br><span class="line">输出</span><br><span class="line">Loop <span class="number">1</span></span><br><span class="line">Loop <span class="number">2</span></span><br><span class="line">Loop <span class="number">3</span></span><br><span class="line">Loop <span class="number">4</span></span><br><span class="line">Loop <span class="number">5</span></span><br><span class="line">Loop <span class="number">6</span></span><br><span class="line">循环正常执行完啦   <span class="comment">#没有被break打断，所以执行了该行代码</span></span><br><span class="line">-----out of <span class="keyword">while</span> loop ------</span><br><span class="line"></span><br><span class="line">如果执行过程中被<span class="keyword">break</span>，就不会执行<span class="keyword">else</span>的语句</span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt;= <span class="number">5</span> :</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Loop&quot;</span>,count)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;循环正常执行完啦&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----out of while loop ------&quot;</span>)</span><br><span class="line">输出</span><br><span class="line">Loop <span class="number">1</span></span><br><span class="line">Loop <span class="number">2</span></span><br><span class="line">-----out of <span class="keyword">while</span> loop ------ <span class="comment">#由于循环被break打断了，所以不执行else后的输出语句</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">练习<span class="number">1</span>：</span><br><span class="line"></span><br><span class="line">寻找<span class="number">1</span>到<span class="number">100</span>之间数字<span class="number">7</span>最大的倍数（结果是<span class="number">98</span>）</span><br><span class="line">number=<span class="number">100</span></span><br><span class="line"><span class="keyword">while</span> number&gt;<span class="number">0</span>:</span><br><span class="line">    <span class="keyword">if</span> number%<span class="number">7</span>==<span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(number)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    number-=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">练习<span class="number">2</span>：</span><br><span class="line">age=<span class="number">18</span></span><br><span class="line">count=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count&lt;<span class="number">3</span>:</span><br><span class="line">    count+=<span class="number">1</span></span><br><span class="line">    guess = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;&gt;&gt;:&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> guess &gt; age :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;猜的太大了，往小里试试...&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> guess &lt; age :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;猜的太小了，往大里试试...&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;恭喜你，猜对了...&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="for循环语法"><a href="#for循环语法" class="headerlink" title="for循环语法"></a>for循环语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">循环结构的第二种实现方式是<span class="keyword">for</span>循环，<span class="keyword">for</span>循环可以做的事情<span class="keyword">while</span>循环都可以实现，之所以用<span class="keyword">for</span>循环，是因为在循环取值(即遍历值)时，<span class="keyword">for</span>循环比<span class="keyword">while</span>循环的使用更为简洁</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>循环语法如下 ↓↓↓</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> 变量名 <span class="keyword">in</span> 可迭代对象: <span class="comment"># 此时只需知道可迭代对象可以是字符串\列表\字典，我们之后会专门讲解可迭代对象</span></span><br><span class="line">        代码一</span><br><span class="line">        代码二</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">#例1</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]:</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line">    <span class="comment"># 运行结果</span></span><br><span class="line">    a</span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 参照例1来介绍for循环的运行步骤</span></span><br><span class="line">    <span class="comment"># 步骤1：从列表[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]中读出第一个值赋值给item（item=‘a’），然后执行循环体代码</span></span><br><span class="line">    <span class="comment"># 步骤2：从列表[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]中读出第二个值赋值给item（item=‘b’），然后执行循环体代码</span></span><br><span class="line">    <span class="comment"># 步骤3: 重复以上过程直到列表中的值读尽</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pic1.zhimg.com/80/v2-7d7dc5ae41a09a7cd6e043d75c63b81c_720w.jpg" alt="img"></p>
<h3 id="for循环应用案例"><a href="#for循环应用案例" class="headerlink" title="for循环应用案例"></a>for循环应用案例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">案例一：打印数字<span class="number">0</span>-<span class="number">5</span></span><br><span class="line"><span class="comment"># 简单版：for循环的实现方式</span></span><br><span class="line"><span class="keyword">for</span> count <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):  <span class="comment"># range(6)会产生从0-5这6个数</span></span><br><span class="line">    <span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复杂版：while循环的实现方式</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">6</span>:</span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">    count += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">案例二：遍历字典</span><br><span class="line"><span class="comment"># 简单版：for循环的实现方式</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;jason&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>,<span class="string">&#x27;gender&#x27;</span>:<span class="string">&#x27;male&#x27;</span>&#125;:  <span class="comment"># for 循环默认取的是字典的key赋值给变量名k</span></span><br><span class="line">    <span class="built_in">print</span>(k)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复杂版：while循环确实可以遍历字典，后续将会迭代器部分详细介绍</span></span><br><span class="line"></span><br><span class="line">案例三：<span class="keyword">for</span>循环嵌套</span><br><span class="line"><span class="comment">#请用for循环嵌套的方式打印如下图形：</span></span><br><span class="line">*****</span><br><span class="line">*****</span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()  <span class="comment"># print()表示换行</span></span><br><span class="line"></span><br><span class="line">注意：<span class="keyword">break</span> 与 <span class="keyword">continue</span>也可以用于<span class="keyword">for</span>循环，使用语法同<span class="keyword">while</span>循环</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">练习一：</span><br><span class="line"></span><br><span class="line">打印九九乘法表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,i+<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s*%s=%s&#x27;</span> %(i,j,i*j),end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">练习二：</span><br><span class="line"></span><br><span class="line">打印金字塔</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">#max_level=5</span></span><br><span class="line"><span class="string">     *        # current_level=1，空格数=4，*号数=1</span></span><br><span class="line"><span class="string">    ***       # current_level=2,空格数=3,*号数=3</span></span><br><span class="line"><span class="string">   *****      # current_level=3,空格数=2,*号数=5</span></span><br><span class="line"><span class="string">  *******     # current_level=4,空格数=1,*号数=7</span></span><br><span class="line"><span class="string"> *********    # current_level=5,空格数=0,*号数=9</span></span><br><span class="line"><span class="string">数学表达式</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">空格数=max_level-current_level</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">号数=2current_level-1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现：</span></span><br><span class="line"></span><br><span class="line">max_level=<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> current_level <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,max_level+<span class="number">1</span>):</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_level-current_level):</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>,end=<span class="string">&#x27;&#x27;</span>) <span class="comment">#在一行中连续打印多个空格</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(2current_level-<span class="number">1</span>):</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>,end=<span class="string">&#x27;&#x27;</span>) <span class="comment">#在一行中连续打印多个空格</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/11/12/%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="池劲涛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="池劲涛的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/12/%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">绑定方法与非绑定方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-12 07:20:25" itemprop="dateCreated datePublished" datetime="2018-11-12T07:20:25+08:00">2018-11-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-12-01 12:22:34" itemprop="dateModified" datetime="2018-12-01T12:22:34+08:00">2018-12-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Python系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h1><ul>
<li>绑定方法与非绑定方法</li>
<li>非绑定方法</li>
</ul>
<h1 id="内容详细"><a href="#内容详细" class="headerlink" title="内容详细"></a>内容详细</h1><h2 id="绑定方法与非绑定方法"><a href="#绑定方法与非绑定方法" class="headerlink" title="绑定方法与非绑定方法"></a>绑定方法与非绑定方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">类中定义的函数分为两大类：</span><br><span class="line">    <span class="number">1</span> 绑定方法</span><br><span class="line">    <span class="number">2</span> 非绑定方法</span><br><span class="line"></span><br><span class="line">其中绑定方法又分为两种：</span><br><span class="line">    <span class="number">1.1</span> 绑定到对象的对象方法</span><br><span class="line">    <span class="number">1.2</span> 绑定到类的类方法</span><br><span class="line">    </span><br><span class="line">在类中正常定义的函数默认是绑定到对象的，而为某个函数加上装饰器@<span class="built_in">classmethod</span>后，该函数就绑定到了类</span><br><span class="line"></span><br><span class="line">类方法通常用来在__init__的基础上提供额外的初始实例化的方式</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置文件settings.py的内容</span></span><br><span class="line">HOST=<span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">PORT=<span class="number">3306</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类方法的应用</span></span><br><span class="line"><span class="keyword">import</span> settings</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQL</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,host,port</span>):</span></span><br><span class="line">        self.host=host</span><br><span class="line">        self.port=port</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_conf</span>(<span class="params">cls</span>):</span> <span class="comment"># 从配置文件中读取配置进行初始化</span></span><br><span class="line">        <span class="keyword">return</span> cls(settings.HOST,settings.PORT)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MySQL.from_conf <span class="comment"># 绑定到类的方法</span></span><br><span class="line">&lt;bound method MySQL.from_conf of &lt;<span class="class"><span class="keyword">class</span> ‘<span class="title">__main__</span>.<span class="title">MySQL</span>&#x27;&gt;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">conn</span>=<span class="title">MySQL</span>.<span class="title">from_conf</span>() # 调用类方法，自动将类<span class="title">MySQL</span>当作第一个参数传给<span class="title">cls</span></span></span><br></pre></td></tr></table></figure>

<p><strong>绑定到类的方法就是专门给类用的，(虽然对象也可以调用，只不过自动传入的第一个参数仍然是类，也就是说这种调用时没有意义的，且容易引起混淆)</strong></p>
<p><strong>ps：这也是python的对象系统与其他面向对象语言对象系统的区别之一，比如Smalltalk和Ruby中，绑定到类的方法与绑定到对象的方法是严格区分开的。</strong> </p>
<h2 id="非绑定方法"><a href="#非绑定方法" class="headerlink" title="非绑定方法"></a>非绑定方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">为类中某个函数加上装饰器@<span class="built_in">staticmethod</span>后，该函数就变成了非绑定方法，也称为静态方法</span><br><span class="line"></span><br><span class="line">该方法不与类或对象绑定，类与对象都可以来调用它，但它就是一个普通函数而已，没有自动传值的功能</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQL</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,host,port</span>):</span></span><br><span class="line">        self.<span class="built_in">id</span>=self.create_id()</span><br><span class="line">        self.host=host</span><br><span class="line">        self.port=port</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_id</span>():</span></span><br><span class="line">        <span class="keyword">return</span> uuid.uuid1()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn=MySQL(‘<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">&#x27;,3306)</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; print(conn.id) #100365f6-8ae0-11e7-a51e-0088653ea1ec</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 类或对象来调用create_id发现都是普通函数，而非绑定到谁的方法</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; MySQL.create_id</span></span><br><span class="line"><span class="string">&lt;function MySQL.create_id at 0x1025c16a8&gt;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; conn.create_id</span></span><br><span class="line"><span class="string">&lt;function MySQL.create_id at 0x1025c16a8&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>若类中需要一个功能，该功能的实现代码中需要引用对象则将其定义成对象方法，需要引用类则将其定义成类方法，无需引用类或对象则将其定义成静态方法</strong> </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/11/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="池劲涛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="池劲涛的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BB/" class="post-title-link" itemprop="url">编程语言分类</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-12 07:20:25" itemprop="dateCreated datePublished" datetime="2018-11-12T07:20:25+08:00">2018-11-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-12-01 12:22:34" itemprop="dateModified" datetime="2018-12-01T12:22:34+08:00">2018-12-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Python系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h2><p><strong>机器语言是站在计算机(奴隶)的角度，说计算机能听懂/理解的语言，而计算机能直接理解的就是二进制指令，所以机器语言就是直接用二进制编程，这意味着机器语言是直接操作硬件的，因此机器语言属于低级语言，此处的低级指的是底层、贴近计算机硬件</strong></p>
<p> <strong>总结</strong><br>     <strong>1、执行效率最高</strong><br>        <strong>编写的程序可以被计算机无障碍理解、直接运行，执行效率高 。</strong></p>
<pre><code> **2、开发效率最低**
    **复杂，开发效率低**

 **3、跨平台性差**
    **贴近\依赖具体的硬件，跨平台性差**
</code></pre>
<h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><p><strong>汇编语言仅仅是用一个英文标签代表一组二进制指令，毫无疑问，比起机器语言，汇编语言是一种进步，但汇编语言的本质仍然是直接操作硬件，因此汇编语言仍是比较低级/底层的语言、贴近计算机硬件</strong></p>
<p>​     <strong>总结</strong><br>​         <strong>1、执行效率高</strong><br>​            <strong>相对于机器语言，使用英文标签编写程序相对简单，执行效率高，但较之机器语言稍低，</strong></p>
<p>​        <strong>2、开发效率低：</strong><br>​            <strong>仍然是直接操作硬件，比起机器语言来说，复杂度稍低，但依旧居高不下，所以开发效率依旧较低</strong></p>
<pre><code>     **3、跨平台性差**
**同样依赖具体的硬件，跨平台性差**
</code></pre>
<h2 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    高级语言是站在人(奴隶主)的角度，说人话，即用人类的字符去编写程序，而人类的字符是在向操作系统发送指令，而非直接操作硬件，所以高级语言是与操作系统打交道的，此处的高级指的是高层、开发者无需考虑硬件细节，因而开发效率可以得到极大的提升，但正因为高级语言离硬件较远，更贴近人类语言，人类可以理解，而计算机则需要通过翻译才能理解，所以执行效率会低于低级语言。</span><br><span class="line"></span><br><span class="line">按照翻译的方式的不同，高级语言又分为两种：</span><br></pre></td></tr></table></figure>



<h3 id="编译型-如C语言"><a href="#编译型-如C语言" class="headerlink" title="编译型(如C语言)"></a>编译型(如C语言)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>、执行效率高</span><br><span class="line">    编译是指在应用源程序执行之前，就将程序源代码“翻译”成目标代码（即机器语言），</span><br><span class="line">因此其目标程序可以脱离其语言环境独立执行，使用比较方便，执行效率较高。</span><br><span class="line"></span><br><span class="line"> <span class="number">2</span>、开发效率低：</span><br><span class="line">    应用程序一旦需要修改，必须先修改源代码，然后重新编译、生成新的目标文件才能执行，</span><br><span class="line">而在只有目标文件而没有源代码，修改会很不方便。所以开发效率低于解释型</span><br><span class="line"></span><br><span class="line"> <span class="number">3</span>、跨平台性差</span><br><span class="line">    编译型代码是针对某一个平台翻译的，当前平台翻译的结果无法拿到不同的平台使用，针对不同的平台必须重新编译，即跨平台性差</span><br><span class="line"></span><br><span class="line"> 其他</span><br><span class="line">    现在大多数的编程语言都是编译型的。</span><br><span class="line">编译程序将源程序翻译成目标程序后保存在另一个文件中，该目标程序可脱离编译程序直接在计算机上多次运行。</span><br><span class="line">大多数软件产品都是以目标程序形式发行给用户的，不仅便于直接运行，同时又使他人难于盗用其中的技术。</span><br><span class="line">C、C++、Ada、Pascal都是编译实现的</span><br></pre></td></tr></table></figure>



<h3 id="解释型-如python"><a href="#解释型-如python" class="headerlink" title="解释型(如python)"></a>解释型(如python)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>、执行效率低</span><br><span class="line">    解释型语言的实现中，翻译器并不产生目标机器代码，而是产生易于执行的中间代码。</span><br><span class="line">这种中间代码与机器代码是不同的，中间代码的解释是由软件支持的，不能直接使用硬件，</span><br><span class="line">软件解释器通常会导致执行效率较低。</span><br><span class="line"></span><br><span class="line"> <span class="number">2</span>、开发效率高</span><br><span class="line">    用解释型语言编写的程序是由另一个可以理解中间代码的解释程序执行的，与编译程序不同的是，</span><br><span class="line">解释程序的任务是逐一将源程序的语句解释成可执行的机器指令，不需要将源程序翻译成目标代码再执行。</span><br><span class="line">解释程序的优点是当语句出现语法错误时，可以立即引起程序员的注意，而程序员在程序开发期间就能进行校正。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="number">3</span>、跨平台性强</span><br><span class="line">    代码运行是依赖于解释器，不同平台有对应版本的解释器，所以解释型的跨平台性强</span><br><span class="line"></span><br><span class="line"> 其他</span><br><span class="line">    对于解释型Basic语言，需要一个专门的解释器解释执行Basic程序，每条语句只有在执行时才被翻译，</span><br><span class="line">这种解释型语言每执行一次就翻译一次，因而效率低下。一般地，动态语言都是解释型的，</span><br><span class="line">例如：Tcl、Perl、Ruby、VBScript、JavaScript等</span><br></pre></td></tr></table></figure>



<h3 id="PS-混合型语言"><a href="#PS-混合型语言" class="headerlink" title="PS(混合型语言)"></a>PS(混合型语言)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    Java是一类特殊的编程语言，Java程序也需要编译，但是却没有直接编译为机器语言，而是编译为字节码，</span><br><span class="line">然后在Java虚拟机上以解释方式执行字节码。</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、执行效率：机器语言&gt;汇编语言&gt;高级语言（编译型&gt;解释型）</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、开发效率：机器语言&lt;汇编语言&lt;高级语言（编译型&lt;解释型）</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、跨平台性：解释型具有极强的跨平台型</span><br></pre></td></tr></table></figure>



<h2 id="python介绍"><a href="#python介绍" class="headerlink" title="python介绍"></a>python介绍</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    谈及python，涉及两层意思，一层代表的是python这门语言的语法风格，另外一层代表的则是专门用来解释该语法风格的应用程序：python解释器。</span><br><span class="line"></span><br><span class="line">• python的创始人为吉多·范罗苏姆（Guido van Rossum）。Python这个名字，来自Guido所挚爱的电视剧Monty Python’s Flying Circus，他希望这个新的叫做Python的语言，能符合他的理想：创造一种C和shell之间，语法能够像shell一样简洁，易学易用、可拓展性强，同时兼顾C的强大功能。于是Guido在<span class="number">1989</span>年的圣诞节期间，开始编写能够解释Python语言语法的解释器。</span><br><span class="line"></span><br><span class="line">• Python崇尚优美、清晰、简单，是一个优秀并广泛使用的语言。最新的TIOBE排行榜https://www.tiobe.com/tiobe-index/，Python已飙升至世界第三。</span><br><span class="line"></span><br><span class="line">• Python可以应用于众多领域，如：人工智能、数据分析、爬虫、金融量化、云计算、WEB开发、自动化运维/测试、游戏开发、网络服务、图像处理等众多领域。目前业内几乎所有大中型互联网企业都在使用Python，如：Youtube、Dropbox、BT、Quora（中国知乎）、豆瓣、知乎、Google、Yahoo!、Facebook、NASA、百度、腾讯、汽车之家、美团等。</span><br></pre></td></tr></table></figure>



<h2 id="Python解释器的发展史"><a href="#Python解释器的发展史" class="headerlink" title="Python解释器的发展史"></a>Python解释器的发展史</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Granddaddy of Python web frameworks, Zope <span class="number">1</span> was released <span class="keyword">in</span> <span class="number">1999</span></span><br><span class="line"></span><br><span class="line">Python <span class="number">1.0</span> - January <span class="number">1994</span> 增加了 <span class="keyword">lambda</span>, <span class="built_in">map</span>, <span class="built_in">filter</span> <span class="keyword">and</span> reduce.</span><br><span class="line"></span><br><span class="line">Python <span class="number">2.0</span> - October <span class="number">16</span>, <span class="number">2000</span>，加入了内存回收机制，构成了现在Python语言框架的基础</span><br><span class="line"></span><br><span class="line">Python <span class="number">2.4</span> - November <span class="number">30</span>, <span class="number">2004</span>, 同年目前最流行的WEB框架Django 诞生</span><br><span class="line"></span><br><span class="line">Python <span class="number">2.5</span> - September <span class="number">19</span>, <span class="number">2006</span></span><br><span class="line"></span><br><span class="line">Python <span class="number">2.6</span> - October <span class="number">1</span>, <span class="number">2008</span></span><br><span class="line"></span><br><span class="line">Python <span class="number">2.7</span> - July <span class="number">3</span>, <span class="number">2010</span></span><br><span class="line"></span><br><span class="line">Python <span class="number">3.1</span> - June <span class="number">27</span>, <span class="number">2009</span></span><br><span class="line"></span><br><span class="line">Python <span class="number">3.2</span> - February <span class="number">20</span>, <span class="number">2011</span></span><br><span class="line"></span><br><span class="line">Python <span class="number">3.3</span> - September <span class="number">29</span>, <span class="number">2012</span></span><br><span class="line"></span><br><span class="line">Python <span class="number">3.4</span> - March <span class="number">16</span>, <span class="number">2014</span></span><br><span class="line"></span><br><span class="line">Python <span class="number">3.5</span> - September <span class="number">13</span>, <span class="number">2015</span></span><br><span class="line"></span><br><span class="line">Python <span class="number">3.6</span> - <span class="number">2016</span>-<span class="number">12</span>-<span class="number">23</span> 发布python3<span class="number">.6</span><span class="number">.0</span>版</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/11/12/%E8%A3%85%E9%A5%B0%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="池劲涛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="池劲涛的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/12/%E8%A3%85%E9%A5%B0%E5%99%A8/" class="post-title-link" itemprop="url">装饰器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-12 07:20:25" itemprop="dateCreated datePublished" datetime="2018-11-12T07:20:25+08:00">2018-11-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-12-01 12:22:34" itemprop="dateModified" datetime="2018-12-01T12:22:34+08:00">2018-12-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Python系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h1><ul>
<li>装饰器介绍</li>
<li>装饰器的实现</li>
</ul>
<h1 id="内容详细："><a href="#内容详细：" class="headerlink" title="内容详细："></a>内容详细：</h1><h1 id="装饰器介绍"><a href="#装饰器介绍" class="headerlink" title="装饰器介绍"></a>装饰器介绍</h1><h2 id="为何要用装饰器"><a href="#为何要用装饰器" class="headerlink" title="为何要用装饰器"></a>为何要用装饰器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">软件的设计应该遵循开放封闭原则，即对扩展是开放的，而对修改是封闭的</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对扩展开放：意味着有新的需求或变化时，可以对现有的代码进行扩展，以适应新的情况</span></span><br><span class="line"><span class="comment"># 对修改封闭：意味着对象一旦设计完成，就可以独立完成其工作，而不要对其进行修改</span></span><br><span class="line"></span><br><span class="line">软件包含的所有的功能的源代码以及调用方式，都应该避免修改，否则一旦改错，极有可能产生连锁反应，最终导致程序崩溃，而对于上线后的软件，新需求或者变化又层出不穷，我们必须为程序提供扩展的可能性，这就用到了装饰器</span><br></pre></td></tr></table></figure>

<h2 id="什么是装饰器"><a href="#什么是装饰器" class="headerlink" title="什么是装饰器"></a>什么是装饰器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;装饰&#x27;</span>:代指为被装饰对象添加新的功能</span><br><span class="line"><span class="string">&#x27;器&#x27;</span>:代指器具/工具</span><br><span class="line">装饰器与被装饰的对象均可以是任意可调用对象</span><br><span class="line"></span><br><span class="line"><span class="comment"># 概括的讲，装饰器的作用就是：在不修改被装饰对象源代码和调用方式的前提下 ---&gt; 为被装饰对象添加额外的功能</span></span><br><span class="line"></span><br><span class="line">装饰器经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等应用场景</span><br><span class="line">装饰器是解决这类问题的绝佳设计，有了装饰器，就可以抽离出大量与函数功能本身无关的雷同代码并继续重用</span><br><span class="line"></span><br><span class="line">ps：可调用对象有函数、方法或者类</span><br></pre></td></tr></table></figure>

<h1 id="装饰器的实现"><a href="#装饰器的实现" class="headerlink" title="装饰器的实现"></a>装饰器的实现</h1><p><strong>函数装饰器分为：’无参装饰器’和’有参装饰器’两种，二者的实现原理一样，都是’函数嵌套+闭包+函数对象’的组合使用的产物</strong></p>
<h2 id="无参装饰器的实现"><a href="#无参装饰器的实现" class="headerlink" title="无参装饰器的实现"></a>无参装饰器的实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如果想为下述函数添加统计其执行时间的功能</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Welcome to the index page’)</span></span><br><span class="line"><span class="string">    return 200</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">index() #函数执行</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">遵循不修改被装饰对象源代码的原则，我们想到的解决方法可能是这样：</span><br><span class="line"></span><br><span class="line">strat_time = time.time()</span><br><span class="line">index() <span class="comment"># 函数执行</span></span><br><span class="line">stop_time = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;run time is %s&#x27;</span> %(stop_time-start_time))  </span><br><span class="line">考虑到还有可能要统计其他函数的执行时间，于是我们将其做成一个单独的工具，函数体需要外部传入被装饰的函数从而进行调用，我们可以使用参数的形式传入</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">func</span>):</span> <span class="comment"># 通过参数接收外部的值</span></span><br><span class="line">    start_time=time.time()</span><br><span class="line">    res=func()</span><br><span class="line">    stop_time=time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;run time is %s&#x27;</span> %(stop_time-start_time))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">但之后函数的调用方式都需要统一改成：</span><br><span class="line">wrapper(index)</span><br><span class="line">wrapper(其他函数)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">========================================================================================</span><br><span class="line"></span><br><span class="line">但这就违反了不能修改被装饰对象调用方式的原则，于是我们换一种为函数体传值的方式，即将值包给函数，如下：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span> <span class="comment"># 引用外部作用域的变量func</span></span><br><span class="line">        start_time=time.time()</span><br><span class="line">        res=func()</span><br><span class="line">        stop_time=time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;run time is %s&#x27;</span> %(stop_time-start_time))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper   </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这样我们便可以在不修改被装饰函数源代码和调用方式的前提下，为其添加上统计时间的功能，只不过需要事先执行一次timer将被装饰的函数传入，返回一个闭包函数wrapper重新赋值给变量名/函数名index 如下：</span><br><span class="line"></span><br><span class="line">index = timer(index) <span class="comment"># 得到index = wrapper，wrapper携带对外作用域的引用：func = 原始的index</span></span><br><span class="line">index() <span class="comment"># 执行的是wrapper(),在wrapper的函数体内再执行最原始的index</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">========================================================================================</span><br><span class="line"></span><br><span class="line">至此我们便实现了一个无参装饰器timer，可以在不修改被装饰对象index源代码和调用方式的前提下为其加上新功能</span><br><span class="line">但我们忽略了若被装饰的函数是一个有参函数，便会抛出异常</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>(<span class="params">name</span>):</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Welcome to the home page&#x27;</span>,name)</span><br><span class="line"></span><br><span class="line">home=timer(home)</span><br><span class="line">home(<span class="string">&#x27;egon&#x27;</span>)</span><br><span class="line"><span class="comment">#抛出异常</span></span><br><span class="line">TypeError: wrapper() takes <span class="number">0</span> positional arguments but <span class="number">1</span> was given</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">========================================================================================</span><br><span class="line"> </span><br><span class="line">之所以会抛出异常，是因为home(<span class="string">&#x27;egon&#x27;</span>)调用的其实是wrapper(<span class="string">&#x27;egon&#x27;</span>),而函数wrapper没有参数</span><br><span class="line">wrapper函数接收的参数其实是给最原始的func用的，为了能满足被装饰函数参数的所有情况</span><br><span class="line">要使用：*args + **kwargs的组合，于是 ---&gt; 最终版装饰器timer如下：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        start_time=time.time()</span><br><span class="line">        res=func(*args,**kwargs)</span><br><span class="line">        stop_time=time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;run time is %s&#x27;</span> %(stop_time-start_time))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper   </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">此时我们就可以用timer来装饰带参数或不带参数的函数了，但是为了简洁而优雅地使用装饰器</span><br><span class="line">python提供了专门的装饰器语法来取代index = timer(index)的形式</span><br><span class="line">        <span class="comment"># 需要在被装饰对象的正上方单独一行添加@timer</span></span><br><span class="line">当解释器解释到@timer时就会调用timer函数，且把它正下方的函数名当做实参传入，然后将返回的结果重新赋值给原函数名</span><br><span class="line">          </span><br><span class="line"><span class="meta">@timer </span><span class="comment"># index=timer(index)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Welcome to the index page&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span></span><br><span class="line"><span class="meta">@timer </span><span class="comment"># index=timer(home)•          def home(name):</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Welcome to the home page’,name)</span></span><br><span class="line"><span class="string">如果我们有多个装饰器，可以叠加多个</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@deco3</span></span><br><span class="line"><span class="string">@deco2</span></span><br><span class="line"><span class="string">@deco1</span></span><br><span class="line"><span class="string">def index():</span></span><br><span class="line"><span class="string">    pass</span></span><br><span class="line"><span class="string">叠加多个装饰器也无特殊之处，上述代码语义如下：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">index=deco3(deco2(deco1(index)))    </span></span><br></pre></td></tr></table></figure>

<h2 id="有参装饰器的实现"><a href="#有参装饰器的实现" class="headerlink" title="有参装饰器的实现"></a>有参装饰器的实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在了解了无参装饰器的实现原理之后，我们可以再实现一个用来为被装饰对象添加认证功能的装饰器，实现的基本形式如下：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        编写基于文件的认证,认证通过则执行res=func(*args,**kwargs),并返回res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">如果我们想提供多种不同的认证方式以供选择，单从wrapper函数的实现角度改写如下</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">            <span class="keyword">if</span> driver == <span class="string">&#x27;file&#x27;</span>:</span><br><span class="line">                编写基于文件的认证,认证通过则执行res=func(*args,**kwargs),并返回res</span><br><span class="line">            <span class="keyword">elif</span> driver == <span class="string">&#x27;mysql&#x27;</span>:</span><br><span class="line">                编写基于mysql认证,认证通过则执行res=func(*args,**kwargs),并返回res</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数wrapper需要一个driver参数，而函数deco与wrapper的参数都有其特定的功能，不能用来接受其他类别的参数，可以再deco的外部再包一层函数auth，用来专门接受额外的参数，这样便保证了再auth函数内无论多少层都可以引用到</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span>(<span class="params">driver</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deco</span>(<span class="params">func</span>):</span></span><br><span class="line">        ……</span><br><span class="line">    <span class="keyword">return</span> deco</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">此时我们就实现了一个有参装饰器，使用方式如下</span><br><span class="line"></span><br><span class="line">先调用auth_type(driver=<span class="string">&#x27;file&#x27;</span>)，得到@deco，deco是一个闭包函数，</span><br><span class="line">包含了对外部作用域名字driver的引用，@deco的语法意义与无参装饰器一样</span><br><span class="line"><span class="meta">@auth(<span class="params">driver=<span class="string">&#x27;file&#x27;</span></span>) </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span>     </span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">@auth(<span class="params">driver=<span class="string">&#x27;mysql&#x27;</span></span>) </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>():</span></span><br><span class="line">    <span class="keyword">pass</span>  </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以使用<span class="built_in">help</span>(函数名)来查看函数的文档注释，本质就是查看函数的doc属性，但对于被装饰之后的函数，查看文档注释</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    home page function</span></span><br><span class="line"><span class="string">    :param name: str</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Welcome to the home page&#x27;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">help</span>(home))</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"></span><br><span class="line">Help on function wrapper <span class="keyword">in</span> module __main__:</span><br><span class="line"></span><br><span class="line">wrapper(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在被装饰之后home=wrapper,查看home.name也可以发现home的函数名确实是wrapper，想要保留原函数的文档和函数名属性，需要修正装饰器</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        start_time=time.time()</span><br><span class="line">        res=func(*args,**kwargs)</span><br><span class="line">        stop_time=time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;run time is %s&#x27;</span> %(stop_time-start_time))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    wrapper.__doc__=func.__doc__</span><br><span class="line">    wrapper.__name__=func.__name__</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">按照上述方式来实现保留原函数属性过于麻烦，functools模块下提供一个装饰器wraps专门用来帮我们实现这件事，用法如下</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        start_time=time.time()</span><br><span class="line">        res=func(*args,**kwargs)</span><br><span class="line">        stop_time=time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;run time is %s&#x27;</span> %(stop_time-start_time))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/11/12/%E7%94%9F%E6%88%90%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="池劲涛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="池劲涛的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/12/%E7%94%9F%E6%88%90%E5%99%A8/" class="post-title-link" itemprop="url">生成器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-12 07:20:25" itemprop="dateCreated datePublished" datetime="2018-11-12T07:20:25+08:00">2018-11-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-12-01 12:22:34" itemprop="dateModified" datetime="2018-12-01T12:22:34+08:00">2018-12-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Python系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h1><ul>
<li>生成器与yield</li>
<li>yield表达式应用</li>
<li>三元表达式、列表生成式、生成器表达式</li>
</ul>
<h1 id="内容详细"><a href="#内容详细" class="headerlink" title="内容详细"></a>内容详细</h1><h2 id="生成器与yield"><a href="#生成器与yield" class="headerlink" title="生成器与yield"></a>生成器与yield</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">若函数体包含<span class="keyword">yield</span>关键字，再调用函数，并不会执行函数体代码，得到的返回值即生成器对象</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">my_range</span>(<span class="params">start,stop,step=<span class="number">1</span></span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;start...&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> start &lt; stop:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> start</span><br><span class="line"><span class="meta">... </span>        start+=step</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;end...&#x27;</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g=my_range(<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator <span class="built_in">object</span> my_range at <span class="number">0x104105678</span>&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">生成器内置有__iter__和__next__方法，所以生成器本身就是一个迭代器</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.__iter__</span><br><span class="line">&lt;method-wrapper <span class="string">&#x27;__iter__&#x27;</span> of generator <span class="built_in">object</span> at <span class="number">0x1037d2af0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.__next__</span><br><span class="line">&lt;method-wrapper <span class="string">&#x27;__next__&#x27;</span> of generator <span class="built_in">object</span> at <span class="number">0x1037d2af0</span>&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">所以我们可以用<span class="built_in">next</span>(生成器)触发生成器所对应函数的执行</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g) <span class="comment"># 触发函数执行直到遇到yield则停止,将yield后的值返回，并在当前位置挂起函数</span></span><br><span class="line">start...</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g) <span class="comment"># 再次调用next(g)，函数从上次暂停的位置继续执行，直到重新遇到yield...</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g) <span class="comment"># 周而复始...</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g) <span class="comment"># 触发函数执行没有遇到yield则无值返回，即取值完毕抛出异常结束迭代</span></span><br><span class="line">end...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">既然生成器对象属于迭代器，那么必然可以使用<span class="keyword">for</span>循环迭代：</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> countdown(<span class="number">3</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">countdown start</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">Done!</span><br></pre></td></tr></table></figure>

<p><strong>有了yield关键字，我们就有了一种自定义迭代器的实现方式</strong><br><strong>yield可以用于返回值，但不同于return，函数一旦遇到return就结束了，而yield则可以保存函数的运行状态并挂起函数，用来返回多次值</strong></p>
<h2 id="yield表达式应用"><a href="#yield表达式应用" class="headerlink" title="yield表达式应用"></a>yield表达式应用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在函数内可以采用表达式形式的<span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eater</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ready to eat&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        food = <span class="keyword">yield</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get the food: %s, and start to eat&#x27;</span> % food)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">可以拿到函数的生成器对象持续为函数体send值：</span><br><span class="line"></span><br><span class="line">g = eater() <span class="comment"># 得到生成器对象</span></span><br><span class="line">g</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;generator <span class="built_in">object</span> eater at <span class="number">0x101b6e2b0</span>&gt;</span><br><span class="line"><span class="built_in">next</span>(g) <span class="comment"># 需要事先&#x27;初始化&#x27;一次，让函数挂起在food = yield，等待调用g.send()方法为其传值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ready to eat</span><br><span class="line">g.send(<span class="string">&#x27;包子&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get the food: 包子, <span class="keyword">and</span> start to eat</span><br><span class="line">g.send(<span class="string">&#x27;鸡腿&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get the food: 鸡腿, <span class="keyword">and</span> start to eat</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">针对表达式形式的yield，生成器对象必须事先被初始化一次，让函数挂起在food = yield的位置，等待调用g.send()方法为函数体传值，g.send(None)等同于next(g)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">• 我们可以编写装饰器来完成为所有表达式形式<span class="keyword">yield</span>对应生成器的初始化操作，如下</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        g=func(*args,**kwargs)</span><br><span class="line">        <span class="built_in">next</span>(g)</span><br><span class="line">        <span class="keyword">return</span> g</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@init</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eater</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Ready to eat&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        food=<span class="keyword">yield</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get the food: %s, and start to eat&#x27;</span> %food)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">表达式形式的<span class="keyword">yield</span>也可以用于返回多次值，即变量名=<span class="keyword">yield</span> 值的形式，如下</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">eater</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;Ready to eat&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    food_list=[]</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>        food=<span class="keyword">yield</span> food_list</span><br><span class="line"><span class="meta">... </span>        food_list.append(food)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e=eater()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(e)</span><br><span class="line">Ready to eat</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.send(<span class="string">&#x27;蒸羊羔&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;蒸羊羔&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.send(<span class="string">&#x27;蒸熊掌&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;蒸羊羔&#x27;</span>, <span class="string">&#x27;蒸熊掌&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.send(<span class="string">&#x27;蒸鹿尾儿&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;蒸羊羔&#x27;</span>, <span class="string">&#x27;蒸熊掌&#x27;</span>, <span class="string">&#x27;蒸鹿尾儿&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="三元表达式、列表生成式、生成器表达式"><a href="#三元表达式、列表生成式、生成器表达式" class="headerlink" title="三元表达式、列表生成式、生成器表达式"></a>三元表达式、列表生成式、生成器表达式</h2><h3 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">三元表达式是python为我们提供的一种简化代码的解决方案，语法如下：</span><br><span class="line"></span><br><span class="line"><span class="comment"># res = 条件成立时返回的值 if 条件 else 条件不成立时返回的值</span></span><br><span class="line"></span><br><span class="line">针对下述场景：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max2</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; y:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">res = max2(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">用三元表达式可以一行解决</span><br><span class="line"></span><br><span class="line">x=<span class="number">1</span></span><br><span class="line">y=<span class="number">2</span></span><br><span class="line"><span class="comment"># res = x if x &gt; y else y # 三元表达式 </span></span><br></pre></td></tr></table></figure>

<h3 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">列表生成式是python为我们提供的一种简化代码的解决方案，用来快速生成列表，语法如下：</span><br><span class="line"></span><br><span class="line">[expression <span class="keyword">for</span> item1 <span class="keyword">in</span> iterable1 <span class="keyword">if</span> condition1</span><br><span class="line"><span class="keyword">for</span> item2 <span class="keyword">in</span> iterable2 <span class="keyword">if</span> condition2</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> itemN <span class="keyword">in</span> iterableN <span class="keyword">if</span> conditionN</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">#类似于</span></span><br><span class="line">res=[]</span><br><span class="line"><span class="keyword">for</span> item1 <span class="keyword">in</span> iterable1:</span><br><span class="line">    <span class="keyword">if</span> condition1:</span><br><span class="line">        <span class="keyword">for</span> item2 <span class="keyword">in</span> iterable2:</span><br><span class="line">            <span class="keyword">if</span> condition2</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">for</span> itemN <span class="keyword">in</span> iterableN:</span><br><span class="line">                    <span class="keyword">if</span> conditionN:</span><br><span class="line">                        res.append(expression)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">针对下述场景：</span><br><span class="line"></span><br><span class="line">egg_list=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    egg_list.append(<span class="string">&#x27;鸡蛋%s&#x27;</span> %i)</span><br><span class="line">用列表生成式可以一行解决</span><br><span class="line"></span><br><span class="line"><span class="comment"># egg_list=[&#x27;鸡蛋%s&#x27; %i for i in range(10)]</span></span><br></pre></td></tr></table></figure>

<h3 id="生成式表达式"><a href="#生成式表达式" class="headerlink" title="生成式表达式"></a>生成式表达式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">创建一个生成器对象有两种方式：</span><br><span class="line"><span class="number">1</span> 调用带<span class="keyword">yield</span>关键字的函数</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 生成器表达式 ---&gt; 与列表生成式的语法格式相同，只需要将[]换成()即可：</span><br><span class="line">    （expression <span class="keyword">for</span> item <span class="keyword">in</span> iterable <span class="keyword">if</span> condition）</span><br><span class="line">    </span><br><span class="line">对比列表生成式返回的是一个列表，生成器表达式返回的是一个生成器对象</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g=(x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x101be0ba0</span>&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">对比列表生成式，生成器表达式的优点自然是节省内存（一次只产生一个值在内存中）</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g) <span class="comment">#抛出异常StopIteration</span></span><br><span class="line">如果我们要读取一个大文件的字节数，应该基于生成器表达式的方式完成</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;db.txt&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    nums=(<span class="built_in">len</span>(line) <span class="keyword">for</span> line <span class="keyword">in</span> f)</span><br><span class="line">    total_size=<span class="built_in">sum</span>(nums) <span class="comment"># 依次执行next(nums)，然后累加到一起得到结果= </span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="池劲涛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="池劲涛的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">计算机核心基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-12 07:20:25" itemprop="dateCreated datePublished" datetime="2018-11-12T07:20:25+08:00">2018-11-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-12-01 12:22:34" itemprop="dateModified" datetime="2018-12-01T12:22:34+08:00">2018-12-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Python系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><h2 id="什么是语言？什么是编程语言？为什么要有编程语言"><a href="#什么是语言？什么是编程语言？为什么要有编程语言" class="headerlink" title="什么是语言？什么是编程语言？为什么要有编程语言?"></a>什么是语言？什么是编程语言？为什么要有编程语言?</h2><h2 id="什么是编程？为什么要编程？"><a href="#什么是编程？为什么要编程？" class="headerlink" title="什么是编程？为什么要编程？"></a>什么是编程？为什么要编程？</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.1</span> </span><br><span class="line">    <span class="number">1</span> 语言就是人与人之间沟通的介质(英语、汉语...)</span><br><span class="line">    <span class="number">2</span> 编程语言就是人与计算机之间沟通的介质</span><br><span class="line">    <span class="number">3</span> 为什么要有编程语言，或者说人为什么要与计算机沟通呢？这是因为在编程的世界里，计算机就好比是人的奴隶，人与计算机沟通的目的就是为了奴役计算机，让计算机按照人类的思维逻辑自发地去工作从而把人力解放出来。</span><br><span class="line"><span class="number">1.2</span></span><br><span class="line">    <span class="number">1</span> 编程就是人把自己想命令计算机干的事用编程语言翻译出来并写到文件里(这一系列的文件就是程序)</span><br><span class="line">    <span class="number">2</span> 分为两个层面</span><br><span class="line">        -为了更好的控制人类的奴隶(计算机)，我们需要学习计算机是由什么组成的、它能做什么、它是怎样工作的</span><br><span class="line">        -我们需要学习编程语言，从而把原来需要人力来完成的业务(ATM+购物)交给计算机去做</span><br></pre></td></tr></table></figure>

<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="什么是计算机？"><a href="#什么是计算机？" class="headerlink" title="什么是计算机？"></a>什么是计算机？</h2><p><strong>俗称电脑，即通电的大脑，电脑二字蕴含了人类对计算机的终极期望，希望它能真的像人脑一样去工作，从而解放人力。</strong></p>
<p><strong>懒人奴役的是真正的人，而人是无法不吃、不喝、不睡觉一直工作的，但是计算机作为一台机器是可以做到的，所以把计算机当奴隶是上上之选。</strong></p>
<p><strong>世界是由聪明的懒人统治的，任何时期，总有一群聪明的懒人想要奴隶别人。在奴隶制社会，聪明的懒人奴役的是真正的人，而人是无法不吃、不喝、不睡觉一直工作的，但是计算机作为一台机器是可以做到的，所以把计算机当奴隶是上上之选。</strong></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="计算机的五大组成部分"><a href="#计算机的五大组成部分" class="headerlink" title="计算机的五大组成部分"></a>计算机的五大组成部分</h2><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p><strong>控制器是计算机的指挥系统，用来控制计算机其他组件的运行，相当于人类的大脑</strong></p>
<h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><p><strong>运算器是计算机的运算功能，用来做算术运算和逻辑运算，相当于人脑。<br>PS：控制器 + 运算器 = CPU</strong></p>
<h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><p><strong>存储器是计算机的记忆功能，用来存取数据。</strong></p>
<p><strong>存储器主要分为内存与外存：</strong></p>
<p><strong>内存相当于人的短期记忆。断电数据丢失</strong></p>
<p><strong>外存(如磁盘),相当于记事的本子，断电数据不会丢失，是用来永久保存数据的</strong></p>
<p><strong>ps：内存的存取速度要远远高于外存</strong></p>
<h3 id="输入设备input"><a href="#输入设备input" class="headerlink" title="输入设备input"></a>输入设备input</h3><p><strong>输入设备是计算接收外界输入数据的工具，如键盘、鼠标，相当于人的眼睛或耳朵。</strong></p>
<h3 id="输出设备output"><a href="#输出设备output" class="headerlink" title="输出设备output"></a>输出设备output</h3><p><strong>输出设备是计算机向外输出数据的工具，如显示器、打印机，相当于人说的话，写出的文章。</strong></p>
<p><strong>ps：存储器如内存、磁盘等既是输入设备又是输出设备，统称为IO设备</strong></p>
<h1 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h1><h2 id="操作系统的由来"><a href="#操作系统的由来" class="headerlink" title="操作系统的由来"></a>操作系统的由来</h2><p><strong>大前提：我们编程目的就是为了奴役计算机，让计算机硬件自发地运行起来，然而硬件毕竟是”死的“，硬件的运行都是由软件支配。</strong></p>
<p><strong>倘若我们要开发一个应用程序，比如暴风音影，该软件的一个核心业务就是播放视频，开发者若要编写程序完成播放视频这个业务逻辑，必先涉及到底层硬件硬盘的基本运作（视频文件都是先存放于硬盘中），这意味着开发者在编写业务逻辑代码之前，必须先编写一个控制硬盘基本运行的控制程序，然而这仅仅只是一个开始，事实上，在编写应用程序的业务逻辑前，需要开发者编写出一套完整的控制程序用来控制所有硬件的基本运行（这要求开发者需要详细了解计算机硬件的各种控制细节，例如我们必须把CPU里面所有指令集都掌握一遍），如此，所有的开发者在开发程序时都必须依次开发两种：</strong><br>　　<strong>1、编写一套完整的的控制程序，用来控制硬件的基本运行，以及把复杂的硬件的操作封装成简单的接口</strong><br>　　<strong>2、基于控制程序的接口开发包含一系列业务逻辑的程序，为了与控制程序区分，可以称为应用程序，以ATM这款应用程序为例，业务逻辑有提款、转账、查询余额等</strong><br><strong>综上，对于不同公司的开发者来说，应用程序的业务逻辑各不相同，但硬件的控制程序都大致相同，为了避免所有程序员做重复劳动，以及不用再耗费精力去了解所有硬件的运行细节，有公司专门跳出来承担起控制程序的开发任务，这里所说的控制程序指的就是操作系统。</strong></p>
<p><strong>操作系统的功能就是帮我们把复杂的硬件的控制封装成简单的接口，对于开发应用程序来说只需要调用操作系统提供给我们的接口即可</strong></p>
<h2 id="系统软件与应用软件"><a href="#系统软件与应用软件" class="headerlink" title="系统软件与应用软件"></a>系统软件与应用软件</h2><p><strong>硬件以上运行的都是软件，而软件分为两类：</strong><br>    <strong>一、应用软件（例如qq、word、暴风影音，我们学习python就是为了开发应用软件的）</strong></p>
<p>​    <strong>二、操作系统，操作系统应用软件与硬件之间的一个桥梁，是协调、管理、控制计算机硬件与应用软件资源的控制程序。</strong></p>
<h2 id="计算机系统的三层结构"><a href="#计算机系统的三层结构" class="headerlink" title="计算机系统的三层结构"></a>计算机系统的三层结构</h2><p><img src="https://img2020.cnblogs.com/blog/2342210/202104/2342210-20210421171214070-1978353069.png" alt="img"></p>
<h3 id="一个非常重要的基础概念：平台"><a href="#一个非常重要的基础概念：平台" class="headerlink" title="一个非常重要的基础概念：平台"></a>一个非常重要的基础概念：平台</h3><p><strong>应用程序都是运行于操作系统之上，而操作系统则是运行于硬件之上的，所以承载应用程序的是一台运行有操作系统的计算机，称之为应用程序的运行平台，即：硬件 + 操作系统 == 平台</strong><br><strong>常见的平台有：windows系统+某款硬件、linux系统+某款硬件、ubuntu+某款硬件等，我们在开发应用程序时就需要考虑到应用程序的跨平台性，如果能开发出一款可以在任意平台运行的应用程序，那对于开发者来说真是极大的福音。而决定应用软件的跨平台性的关键因素往往是编程语言的选择，python恰好是一款跨平台性语言，这也是我们学习它的原因之一。</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/2342210/202104/2342210-20210421171226105-104347706.png" alt="img"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/11/12/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="池劲涛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="池劲涛的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/12/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83/" class="post-title-link" itemprop="url">软件开发目录规范</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-12 07:20:25" itemprop="dateCreated datePublished" datetime="2018-11-12T07:20:25+08:00">2018-11-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-12-01 12:22:34" itemprop="dateModified" datetime="2018-12-01T12:22:34+08:00">2018-12-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Python系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h1><ul>
<li>软件开发目录规范</li>
</ul>
<h1 id="内容详细"><a href="#内容详细" class="headerlink" title="内容详细"></a>内容详细</h1><h2 id="软件开发目录规范"><a href="#软件开发目录规范" class="headerlink" title="软件开发目录规范"></a>软件开发目录规范</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">为了提高程序的可读性与可维护性，我们应该为软件设计良好的目录结构，这与规范的编码风格同等重要。软件的目录规范并无硬性标准，只要清晰可读即可，假设你的软件名为foo，笔者推荐目录结构如下</span><br><span class="line"></span><br><span class="line">Foo/</span><br><span class="line">|-- core/</span><br><span class="line">|   |-- core.py</span><br><span class="line">|</span><br><span class="line">|-- api/</span><br><span class="line">|   |-- api.py</span><br><span class="line">|</span><br><span class="line">|-- db/</span><br><span class="line">|   |-- db_handle.py</span><br><span class="line">|</span><br><span class="line">|-- lib/</span><br><span class="line">|   |-- common.py</span><br><span class="line">|</span><br><span class="line">|-- conf/</span><br><span class="line">|   |-- settings.py</span><br><span class="line">|</span><br><span class="line">|-- run.py</span><br><span class="line">|-- setup.py</span><br><span class="line">|-- requirements.txt</span><br><span class="line">|-- README</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">简要解释一下:</span><br><span class="line"></span><br><span class="line"> • core/: 存放业务逻辑相关代码</span><br><span class="line"></span><br><span class="line"> • api/: 存放接口文件，接口主要用于为业务逻辑提供数据操作。</span><br><span class="line"></span><br><span class="line"> • db/: 存放操作数据库相关文件，主要用于与数据库交互</span><br><span class="line"></span><br><span class="line"> • lib/: 存放程序中常用的自定义模块</span><br><span class="line"></span><br><span class="line"> • conf/: 存放配置文件</span><br><span class="line"></span><br><span class="line"> • run.py: 程序的启动文件，一般放在项目的根目录下，因为在运行时会默认将运行文件所在的文件夹作为sys.path的第一个路径，这样就省去了处理环境变量的步骤</span><br><span class="line"></span><br><span class="line"> • setup.py: 安装、部署、打包的脚本。</span><br><span class="line"></span><br><span class="line"> • requirements.txt: 存放软件依赖的外部Python包列表。</span><br><span class="line"></span><br><span class="line"> • README: 项目说明文件。</span><br><span class="line"></span><br><span class="line">除此之外，有一些方案给出了更加多的内容，比如LICENSE.txt,ChangeLog.txt文件等，主要是在项目需要开源时才会用到，请读者自行查阅。</span><br><span class="line"></span><br><span class="line">关于README的内容，这个应该是每个项目都应该有的一个文件，目的是能简要描述该项目的信息，让读者快速了解这个项目。它需要说明以下几个事项:</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、软件定位，软件的基本功能；</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、运行代码的方法: 安装环境、启动命令等；</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、简要的使用说明；</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、代码目录结构说明，更详细点可以说明软件的基本原理；</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、常见问题说明。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关于setup.py和requirements.txt：</span><br><span class="line"></span><br><span class="line">一般来说，用setup.py来管理代码的打包、安装、部署问题。业界标准的写法是用Python流行的打包工具setuptools来管理这些事情，这种方式普遍应用于开源项目中。不过这里的核心思想不是用标准化的工具来解决这些问题，而是说，一个项目一定要有一个安装部署工具，能快速便捷的在一台新机器上将环境装好、代码部署好和将程序运行起来。</span><br><span class="line"></span><br><span class="line">requirements.txt文件的存在是为了方便开发者维护软件的依赖库。我们需要将开发过程中依赖库的信息添加进该文件中，避免在 setup.py安装依赖时漏掉软件包，同时也方便了使用者明确项目引用了哪些Python包。</span><br><span class="line"></span><br><span class="line">这个文件的格式是每一行包含一个包依赖的说明，通常是flask&gt;=<span class="number">0.10</span>这种格式，要求是这个格式能被pip识别，这样就可以简单的通过 pip install -r requirements.txt来把所有Python依赖库都装好了</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/11/12/%E8%BF%AD%E4%BB%A3%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="池劲涛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="池劲涛的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/12/%E8%BF%AD%E4%BB%A3%E5%99%A8/" class="post-title-link" itemprop="url">迭代器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-12 07:20:25" itemprop="dateCreated datePublished" datetime="2018-11-12T07:20:25+08:00">2018-11-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-12-01 12:22:34" itemprop="dateModified" datetime="2018-12-01T12:22:34+08:00">2018-12-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Python系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h1><ul>
<li>迭代器介绍</li>
<li>for循环原理</li>
<li>迭代器的优缺点</li>
</ul>
<h1 id="内容详细"><a href="#内容详细" class="headerlink" title="内容详细"></a>内容详细</h1><h2 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">迭代器即用来迭代取值的工具，而迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果</span><br><span class="line">每一次对工程的重复称为一次<span class="string">&#x27;迭代&#x27;</span>，而每一次迭代得到的结果会作为下一次迭代的初始值，单纯的重复并不是迭代</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = <span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">    <span class="built_in">print</span>(msg)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">下述<span class="keyword">while</span>循环才是一个迭代的过程，不仅满足重复，而且<span class="string">&#x27;每次重新赋值后的index值作为下一次循环中新的索引进行取值，反复迭代，最终可以取尽列表中的值&#x27;</span></span><br><span class="line"></span><br><span class="line">goods = [<span class="string">&#x27;mac&#x27;</span>, <span class="string">&#x27;lenovo&#x27;</span>, <span class="string">&#x27;acer&#x27;</span>, <span class="string">&#x27;dell&#x27;</span>, <span class="string">&#x27;sony&#x27;</span>]</span><br><span class="line"></span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> index &lt; <span class="built_in">len</span>(goods):</span><br><span class="line">    <span class="built_in">print</span>(goods[index])</span><br><span class="line">    index += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">通过索引的方式进行迭代取值，实现简单，但仅适用于序列类型：字符串、列表、元组</span><br><span class="line">但对于没有索引的字典、集合等非序列类型，必须找到一种不依赖索引来进行迭代取值的方式，这就用到了<span class="string">&#x27;迭代器&#x27;</span></span><br><span class="line"></span><br><span class="line">想了解迭代器是什么，必须事先搞清楚一个很重要的概念：可迭代对象</span><br><span class="line"></span><br><span class="line">从语法形式上讲，内置有__inter__方法的对象都是可迭代对象，字符串、列表、元组、字典、集合、打开的文件都是可迭代对象：</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;egon&#x27;</span>&#125;.__iter__</span><br><span class="line">&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;.__iter__</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h3 id="迭代器对象"><a href="#迭代器对象" class="headerlink" title="迭代器对象"></a>迭代器对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">调用obj.<span class="built_in">iter</span>()方法返回的结果就是一个<span class="string">&#x27;迭代器对象&#x27;</span></span><br><span class="line">迭代器对象是内置有<span class="built_in">iter</span>和<span class="built_in">next</span>方法的对象，打开的文件本身就是一个迭代器对象，执行迭代器对象.<span class="built_in">iter</span>()方法得到的仍然是迭代器本身，而执行迭代器.<span class="built_in">next</span>()方法就会计算出迭代器的下一个值</span><br><span class="line">迭代器是python提供的一种统一的、不依赖索引的迭代取值方式，只要存在多个<span class="string">&#x27;值&#x27;</span>，无论序列类型还是非序列类型都可以按照迭代器的方式取值</span><br><span class="line"></span><br><span class="line">s = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment"># 可迭代对象</span></span><br><span class="line">i = <span class="built_in">iter</span>(s) <span class="comment"># 本质就是在调用s.__iter__(),返回s的迭代器对象i</span></span><br><span class="line"><span class="built_in">next</span>(i) <span class="comment"># 本质就是在调用i.__next__()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span></span><br><span class="line"><span class="built_in">next</span>(i)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="built_in">next</span>(i)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span></span><br><span class="line"><span class="built_in">next</span>(i)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 抛出stopiteration的异常，代表无值可取，迭代结束 </span></span><br></pre></td></tr></table></figure>

<h2 id="for循环原理"><a href="#for循环原理" class="headerlink" title="for循环原理"></a>for循环原理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">有了迭代器之后 我们便可以不依赖索引迭代取值了，使用<span class="keyword">while</span>循环的实现方式如下：</span><br><span class="line"></span><br><span class="line">goods=[<span class="string">&#x27;mac&#x27;</span>,<span class="string">&#x27;lenovo&#x27;</span>,<span class="string">&#x27;acer&#x27;</span>,<span class="string">&#x27;dell&#x27;</span>,<span class="string">&#x27;sony&#x27;</span>]</span><br><span class="line">i=<span class="built_in">iter</span>(goods) <span class="comment">#每次都需要重新获取一个迭代器对象</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">next</span>(i))</span><br><span class="line">    <span class="keyword">except</span> StopIteration: <span class="comment">#捕捉异常终止循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>循环又称为迭代循环，<span class="keyword">in</span>后可以跟任意可迭代对象，上述<span class="keyword">while</span>循环可以简写为：</span><br><span class="line"></span><br><span class="line">goods=[<span class="string">&#x27;mac&#x27;</span>,<span class="string">&#x27;lenovo&#x27;</span>,<span class="string">&#x27;acer&#x27;</span>,<span class="string">&#x27;dell&#x27;</span>,<span class="string">&#x27;sony&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> goods:   </span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>

<p><strong>for循环在工作时，首先会调用可迭代对象goods内置的iter方法拿到一个迭代器对象，然后再调用该迭代器对象的next方法将取到的值赋给item，执行循环体完成一次循环，周而复始，直到捕捉stopiteration异常，结束迭代</strong></p>
<h2 id="迭代器的优缺点"><a href="#迭代器的优缺点" class="headerlink" title="迭代器的优缺点"></a>迭代器的优缺点</h2><p> <strong>基于索引的迭代取值，所有迭代的状态都保存在了索引中，而基于迭代器实现迭代的方式不再需要索引，所有迭代的状态就保存在迭代器中，然而这种处理方式优点与缺点并存：</strong></p>
<h3 id="迭代器的优点"><a href="#迭代器的优点" class="headerlink" title="迭代器的优点"></a>迭代器的优点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 为序列和非序列类型提供了一种统一的迭代取值方式</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 惰性计算：迭代器对象表示的是一个数据流，可以只在需要时才去调用<span class="built_in">next</span>来计算出一个值，就迭代器本身来说，同一时          刻在内存中只有一个值，因而可以存放无限大的数据流，而对于其他容器类型，如列表，需要把所有的元素都           存放于内存中，受内存大小的限制，可以存放的值的个数是有限的</span><br></pre></td></tr></table></figure>

<h3 id="迭代器的缺点"><a href="#迭代器的缺点" class="headerlink" title="迭代器的缺点"></a>迭代器的缺点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 除非取尽，否则无法获取迭代器的长度</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 只能取下一个值，不能回到开始，更像是<span class="string">&#x27;一次性的&#x27;</span>，迭代器产生后的唯一目标就是重复执行<span class="built_in">next</span>方法直到值取尽，否则就会停留在某个位置，等待下一次调用<span class="built_in">next</span>；若是要再次迭代同个对象，只能重新调用<span class="built_in">iter</span>方法去创建一个新的迭代器对象，如果有两个或者多个循环使用同一个迭代器，必然只会有一个循环能取到值</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/11/12/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="池劲涛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="池劲涛的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/12/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F/" class="post-title-link" itemprop="url">面向过程与函数式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-12 07:20:25" itemprop="dateCreated datePublished" datetime="2018-11-12T07:20:25+08:00">2018-11-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-12-01 12:22:34" itemprop="dateModified" datetime="2018-12-01T12:22:34+08:00">2018-12-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Python系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h1><ul>
<li>编程范式</li>
<li>面向过程</li>
<li>函数式</li>
</ul>
<h1 id="内容详解"><a href="#内容详解" class="headerlink" title="内容详解"></a>内容详解</h1><h2 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a>编程范式</h2><p><strong>很多初学者在了解了一门编程语言的基本语法和使用后，面对一个开发需求时，仍然会觉得无从下手，没有思路，本节主题’编程范式’正是为了解决该问题，那么到底什么是编程范式呢</strong></p>
<p><strong>编程范式指的就是编程的套路，打个比方：如果把编程的过程比喻为练习武功，那编程范式指的就是武林中的各种流派，而在编程的世界里常见的流派有：面向过程，函数式，面向对象…</strong></p>
<p><strong>强调：’功夫的流派没有高低之分，只有习武的人才有高低之分’，在编程世界里更是这样，各种编程范式在不同的场景下都各有优劣，谁好谁坏不能一概而论</strong></p>
<h2 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;面向过程&#x27;</span>核心是<span class="string">&#x27;过程&#x27;</span>二字，<span class="string">&#x27;过程&#x27;</span>指的是解决问题的步骤 ---&gt; 先干啥 在干啥...</span><br><span class="line"></span><br><span class="line">基于面向过程开发程序就好比在设计一条流水线，是一种机械式的思维方式，这正好契合计算机的运行原理：任何程序的执行最终都需要转换成cpu的指令流水按过程调度执行 ---&gt; 无论采用什么语言，无论依据何种编程范式设计出的程序，最终的执行都是过程式的</span><br><span class="line"></span><br><span class="line">详细的，若程序一开始是要着手解决一个大的问题，按照过程式的思路就是把这个大的问题分解成很多个小问题或子过程去实现，然后依次调用即可，这极大地降低了程序的复杂度。举例如下：</span><br><span class="line"></span><br><span class="line">• 写一个数据远程备份程序，分三步：本地数据打包，上传至云服务器，检测备份文件可用性</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一：基于本章所学，我们可以用函数去实现这一个个的步骤</span></span><br><span class="line"><span class="comment"># 1、本地数据打包</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_backup</span>(<span class="params">folder</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找到备份目录: %s&quot;</span> %folder)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;正在备份...&#x27;</span>)</span><br><span class="line">    zip_file=<span class="string">&#x27;/tmp/backup_%s.zip&#x27;</span> %time.strftime(<span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;备份成功，备份文件为: %s&#x27;</span> %zip_file)</span><br><span class="line">    <span class="keyword">return</span> zip_file</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#2、上传至云服务器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cloud_upload</span>(<span class="params">file</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nconnecting cloud storage center...&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;cloud storage connected&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;upload [%s] to cloud...&quot;</span> %file)</span><br><span class="line">    link=<span class="string">&#x27;https://www.xxx.com/bak/%s&#x27;</span> %os.path.basename(file)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;close connection&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> link</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#3、检测备份文件可用性</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_backup_check</span>(<span class="params">link</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n下载文件: %s , 验证文件是否无损...&quot;</span> %link)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#二：依次调用</span></span><br><span class="line"><span class="comment"># 步骤一：本地数据打包</span></span><br><span class="line">zip_file = data_backup(<span class="string">r&quot;/Users/egon/欧美100G高清无码&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤二：上传至云服务器</span></span><br><span class="line">link=cloud_upload(zip_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤三：检测备份文件的可用性</span></span><br><span class="line">data_backup_check(link)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">面向过程总结：</span></span><br><span class="line"><span class="string">    1 优点：</span></span><br><span class="line"><span class="string">        将复杂的问题流程化，进而简单化</span></span><br><span class="line"><span class="string">    2 缺点：</span></span><br><span class="line"><span class="string">        程序的可扩展性极差，因为一套流水线或者流程就是用来解决一个问题的</span></span><br><span class="line"><span class="string">        就好比生产汽水的流水线无法生产汽车一样，即便是能，也得是大改，而且改一个组件，与其相关的组件可能都需要修改，比如我们修改了cloud_upload的逻辑，那么依赖其结果才能正常执行的data_backup_check也需要修改，这就造成了连锁反应，而且这一问题会随着程序规模的增大而变得越发的糟糕。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cloud_upload</span>(<span class="params">file</span>):</span> <span class="comment"># 加上异常处理，在出现异常的情况下，没有link返回</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\nconnecting cloud storage center...&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;cloud storage connected&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;upload [%s] to cloud...&quot;</span> %file)</span><br><span class="line">        link=<span class="string">&#x27;https://www.xxx.com/bak/%s&#x27;</span> %os.path.basename(file)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;close connection&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> link</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;upload error&#x27;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;close connection.....&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_backup_check</span>(<span class="params">link</span>):</span> <span class="comment"># 加上对参数link的判断</span></span><br><span class="line">    <span class="keyword">if</span> link:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n下载文件: %s , 验证文件是否无损...&quot;</span> %link)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\n链接不存在&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">3 应用场景：</span></span><br><span class="line"><span class="string">    面向过程的程序设计一般用于那些功能一旦实现之后就很少需要改变的场景， 如果你只是写一些简单的脚本，去做一些一次性任务，用面向过程去实现是极好的，但如果你要处理的任务是复杂的，且需要不断迭代和维护， 那还是用面向对象最为方便。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="函数式"><a href="#函数式" class="headerlink" title="函数式"></a>函数式</h2><p><strong>函数式编程并非用函数编程这么简单，而是将计算机的运算视为数学意义上的运算，比起面向过程，函数式更加注重的是执行结果而非执行的过程，代表语言有：Haskell、Erlang。而python并不是一门函数式编程语言，但是仍为我们提供了很多函数式编程好的特性，如lambda，map，reduce，filter</strong></p>
<h3 id="匿名函数与lambda"><a href="#匿名函数与lambda" class="headerlink" title="匿名函数与lambda"></a>匿名函数与lambda</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 使用<span class="function"><span class="keyword">def</span>关键字创建的是有名字的函数</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">2 使用<span class="title">lambda</span>关键字创建的则是没有名字的函数，即匿名函数</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">语法：</span></span><br><span class="line"><span class="function">    <span class="title">lambda</span> 参数1， 参数2，...：</span></span><br><span class="line"><span class="function">        <span class="title">expression</span></span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">举例</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># 1、定义</span></span><br><span class="line"><span class="function"><span class="title">lambda</span> <span class="title">x</span>,<span class="title">y</span>,<span class="title">z</span>:</span>x+y+z</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x,y,z</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x+y+z</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、调用</span></span><br><span class="line"><span class="comment"># 方式一：</span></span><br><span class="line">res=(<span class="keyword">lambda</span> x,y,z:x+y+z)(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二：</span></span><br><span class="line">func=<span class="keyword">lambda</span> x,y,z:x+y+z <span class="comment"># “匿名”的本质就是要没有名字，所以此处为匿名函数指定名字是没有意义的</span></span><br><span class="line">res=func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">匿名函数与有名函数有相同的作用域，但是匿名意味着引用计数为<span class="number">0</span>，使用一次就释放，所以匿名函数用于临时使用一次的场景，匿名函数通常与其他函数配合使用，我们以下述字典为例来介绍它</span><br><span class="line"></span><br><span class="line">salaries=&#123;</span><br><span class="line">    <span class="string">&#x27;siry&#x27;</span>:<span class="number">3000</span>,</span><br><span class="line">    <span class="string">&#x27;tom&#x27;</span>:<span class="number">7000</span>,</span><br><span class="line">    <span class="string">&#x27;lili&#x27;</span>:<span class="number">10000</span>,</span><br><span class="line">    <span class="string">&#x27;jack&#x27;</span>:<span class="number">2000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">要想取得薪水的最大值和最小值，我们可以使用内置函数<span class="built_in">max</span>和<span class="built_in">min</span>（为了方便开发，python解释器已经为我们定义好了一系列常用的功能，称之为内置的函数，我们只需要拿来使用即可）</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(salaries)</span><br><span class="line"><span class="string">&#x27;tom&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">min</span>(salaries)</span><br><span class="line"><span class="string">&#x27;jack&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">内置<span class="built_in">max</span>和<span class="built_in">min</span>都支持迭代器协议，工作原理都是迭代字典，取得是字典的键，因而比较的是键的最大和最小值，而我们想要的是比较值的最大值与最小值，于是做出如下改动</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数max会迭代字典salaries，每取出一个“人名”就会当做参数传给指定的匿名函数，然后将匿名函数的返回值当做比较依据，最终返回薪资最高的那个人的名字</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(salaries,key=<span class="keyword">lambda</span> k:salaries[k]) </span><br><span class="line"><span class="string">&#x27;lili&#x27;</span></span><br><span class="line"><span class="comment"># 原理同上</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">min</span>(salaries,key=<span class="keyword">lambda</span> k:salaries[k])</span><br><span class="line"><span class="string">&#x27;jack&#x27;</span></span><br><span class="line">同理，我们直接对字典进行排序，默认也是按照字典的键去排序的</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(salaries)</span><br><span class="line">[<span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;lili&#x27;</span>, <span class="string">&#x27;siry&#x27;</span>, <span class="string">&#x27;tom&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="map、reduce、filter"><a href="#map、reduce、filter" class="headerlink" title="map、reduce、filter"></a>map、reduce、filter</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">函数<span class="built_in">map</span>、reduce、<span class="built_in">filter</span>都支持迭代器协议，用来处理可迭代对象，我们以一个可迭代对象array为例来介绍它们三个的用法</span><br><span class="line"></span><br><span class="line">array=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">要求一：对array的每个元素做平方处理，可以使用<span class="built_in">map</span>函数</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>函数可以接收两个参数，一个是函数，另外一个是可迭代对象，具体用法如下</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res=<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x**<span class="number">2</span>,array)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line">&lt;<span class="built_in">map</span> <span class="built_in">object</span> at <span class="number">0x1033f45f8</span>&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">解析：<span class="built_in">map</span>会依次迭代array，得到的值依次传给匿名函数（也可以是有名函数），而<span class="built_in">map</span>函数得到的结果仍然是迭代器。</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(res) <span class="comment">#使用list可以依次迭代res，取得的值作为列表元素</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">要求二：对array进行合并操作，比如求和运算，这就用到了reduce函数</span><br><span class="line"></span><br><span class="line">reduce函数可以接收三个参数，一个是函数，第二个是可迭代对象，第三个是初始值</span><br><span class="line"></span><br><span class="line"><span class="comment"># reduce在python2中是内置函数，在python3中则被集成到模块functools中，需要导入才能使用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res=reduce(<span class="keyword">lambda</span> x,y:x+y,array)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">解析：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> 没有初始值，reduce函数会先迭代一次array得到的值作为初始值，作为第一个值数传给x，然后继续迭代一次array得到的值作为第二个值传给y，运算的结果为<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 将上一次reduce运算的结果作为第一个值传给x，然后迭代一次array得到的结果作为第二个值传给y，依次类推，知道迭代完array的所有元素，得到最终的结果<span class="number">15</span></span><br><span class="line"></span><br><span class="line">也可以为reduce指定初始值</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res=reduce(<span class="keyword">lambda</span> x,y:x+y,array,<span class="number">100</span>)•&gt;&gt;&gt; res</span><br><span class="line"><span class="number">115</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">要求三：对array进行过滤操作，这就用到了<span class="built_in">filter</span>函数，比如过滤出大于<span class="number">3</span>的元素</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res=<span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x&gt;<span class="number">3</span>,array)</span><br><span class="line">解析：<span class="built_in">filter</span>函数会依次迭代array，得到的值依次传给匿名函数，如果匿名函数的返回值为真，则过滤出该元素，而<span class="built_in">filter</span>函数得到的结果仍然是迭代器。</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(res) </span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">提示：我们介绍map、filter、reduce只是为了带大家了解函数式编程的大致思想，在实际开发中，我们完全可以用列表生成式或者生成器表达式来实现三者的功能。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span> </span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">池劲涛</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
