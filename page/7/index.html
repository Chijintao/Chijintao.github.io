<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="池劲涛的博客">
<meta property="og:url" content="http://example.com/page/7/index.html">
<meta property="og:site_name" content="池劲涛的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="池劲涛">
<meta property="article:tag" content="Python Linux Vue">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/7/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/7/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>池劲涛的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">池劲涛的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="池劲涛"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">池劲涛</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/11/12/%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="池劲涛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="池劲涛的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/12/%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">绑定方法与非绑定方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-12 07:20:25" itemprop="dateCreated datePublished" datetime="2018-11-12T07:20:25+08:00">2018-11-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-12-01 12:22:34" itemprop="dateModified" datetime="2018-12-01T12:22:34+08:00">2018-12-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Python系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h1><ul>
<li>绑定方法与非绑定方法</li>
<li>非绑定方法</li>
</ul>
<h1 id="内容详细"><a href="#内容详细" class="headerlink" title="内容详细"></a>内容详细</h1><h2 id="绑定方法与非绑定方法"><a href="#绑定方法与非绑定方法" class="headerlink" title="绑定方法与非绑定方法"></a>绑定方法与非绑定方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">类中定义的函数分为两大类：</span><br><span class="line">    <span class="number">1</span> 绑定方法</span><br><span class="line">    <span class="number">2</span> 非绑定方法</span><br><span class="line"></span><br><span class="line">其中绑定方法又分为两种：</span><br><span class="line">    <span class="number">1.1</span> 绑定到对象的对象方法</span><br><span class="line">    <span class="number">1.2</span> 绑定到类的类方法</span><br><span class="line">    </span><br><span class="line">在类中正常定义的函数默认是绑定到对象的，而为某个函数加上装饰器@<span class="built_in">classmethod</span>后，该函数就绑定到了类</span><br><span class="line"></span><br><span class="line">类方法通常用来在__init__的基础上提供额外的初始实例化的方式</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置文件settings.py的内容</span></span><br><span class="line">HOST=<span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">PORT=<span class="number">3306</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类方法的应用</span></span><br><span class="line"><span class="keyword">import</span> settings</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQL</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,host,port</span>):</span></span><br><span class="line">        self.host=host</span><br><span class="line">        self.port=port</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_conf</span>(<span class="params">cls</span>):</span> <span class="comment"># 从配置文件中读取配置进行初始化</span></span><br><span class="line">        <span class="keyword">return</span> cls(settings.HOST,settings.PORT)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>MySQL.from_conf <span class="comment"># 绑定到类的方法</span></span><br><span class="line">&lt;bound method MySQL.from_conf of &lt;<span class="class"><span class="keyword">class</span> ‘<span class="title">__main__</span>.<span class="title">MySQL</span>&#x27;&gt;&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">conn</span>=<span class="title">MySQL</span>.<span class="title">from_conf</span>() # 调用类方法，自动将类<span class="title">MySQL</span>当作第一个参数传给<span class="title">cls</span></span></span><br></pre></td></tr></table></figure>

<p><strong>绑定到类的方法就是专门给类用的，(虽然对象也可以调用，只不过自动传入的第一个参数仍然是类，也就是说这种调用时没有意义的，且容易引起混淆)</strong></p>
<p><strong>ps：这也是python的对象系统与其他面向对象语言对象系统的区别之一，比如Smalltalk和Ruby中，绑定到类的方法与绑定到对象的方法是严格区分开的。</strong> </p>
<h2 id="非绑定方法"><a href="#非绑定方法" class="headerlink" title="非绑定方法"></a>非绑定方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">为类中某个函数加上装饰器@<span class="built_in">staticmethod</span>后，该函数就变成了非绑定方法，也称为静态方法</span><br><span class="line"></span><br><span class="line">该方法不与类或对象绑定，类与对象都可以来调用它，但它就是一个普通函数而已，没有自动传值的功能</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQL</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,host,port</span>):</span></span><br><span class="line">        self.<span class="built_in">id</span>=self.create_id()</span><br><span class="line">        self.host=host</span><br><span class="line">        self.port=port</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_id</span>():</span></span><br><span class="line">        <span class="keyword">return</span> uuid.uuid1()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>conn=MySQL(‘<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">&#x27;,3306)</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; print(conn.id) #100365f6-8ae0-11e7-a51e-0088653ea1ec</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 类或对象来调用create_id发现都是普通函数，而非绑定到谁的方法</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; MySQL.create_id</span></span><br><span class="line"><span class="string">&lt;function MySQL.create_id at 0x1025c16a8&gt;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; conn.create_id</span></span><br><span class="line"><span class="string">&lt;function MySQL.create_id at 0x1025c16a8&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>若类中需要一个功能，该功能的实现代码中需要引用对象则将其定义成对象方法，需要引用类则将其定义成类方法，无需引用类或对象则将其定义成静态方法</strong> </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/11/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="池劲涛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="池劲涛的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/12/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BB/" class="post-title-link" itemprop="url">编程语言分类</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-12 07:20:25" itemprop="dateCreated datePublished" datetime="2018-11-12T07:20:25+08:00">2018-11-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-12-01 12:22:34" itemprop="dateModified" datetime="2018-12-01T12:22:34+08:00">2018-12-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Python系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h2><p><strong>机器语言是站在计算机(奴隶)的角度，说计算机能听懂/理解的语言，而计算机能直接理解的就是二进制指令，所以机器语言就是直接用二进制编程，这意味着机器语言是直接操作硬件的，因此机器语言属于低级语言，此处的低级指的是底层、贴近计算机硬件</strong></p>
<p> <strong>总结</strong><br>     <strong>1、执行效率最高</strong><br>        <strong>编写的程序可以被计算机无障碍理解、直接运行，执行效率高 。</strong></p>
<pre><code> **2、开发效率最低**
    **复杂，开发效率低**

 **3、跨平台性差**
    **贴近\依赖具体的硬件，跨平台性差**
</code></pre>
<h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><p><strong>汇编语言仅仅是用一个英文标签代表一组二进制指令，毫无疑问，比起机器语言，汇编语言是一种进步，但汇编语言的本质仍然是直接操作硬件，因此汇编语言仍是比较低级/底层的语言、贴近计算机硬件</strong></p>
<p>​     <strong>总结</strong><br>​         <strong>1、执行效率高</strong><br>​            <strong>相对于机器语言，使用英文标签编写程序相对简单，执行效率高，但较之机器语言稍低，</strong></p>
<p>​        <strong>2、开发效率低：</strong><br>​            <strong>仍然是直接操作硬件，比起机器语言来说，复杂度稍低，但依旧居高不下，所以开发效率依旧较低</strong></p>
<pre><code>     **3、跨平台性差**
**同样依赖具体的硬件，跨平台性差**
</code></pre>
<h2 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    高级语言是站在人(奴隶主)的角度，说人话，即用人类的字符去编写程序，而人类的字符是在向操作系统发送指令，而非直接操作硬件，所以高级语言是与操作系统打交道的，此处的高级指的是高层、开发者无需考虑硬件细节，因而开发效率可以得到极大的提升，但正因为高级语言离硬件较远，更贴近人类语言，人类可以理解，而计算机则需要通过翻译才能理解，所以执行效率会低于低级语言。</span><br><span class="line"></span><br><span class="line">按照翻译的方式的不同，高级语言又分为两种：</span><br></pre></td></tr></table></figure>



<h3 id="编译型-如C语言"><a href="#编译型-如C语言" class="headerlink" title="编译型(如C语言)"></a>编译型(如C语言)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>、执行效率高</span><br><span class="line">    编译是指在应用源程序执行之前，就将程序源代码“翻译”成目标代码（即机器语言），</span><br><span class="line">因此其目标程序可以脱离其语言环境独立执行，使用比较方便，执行效率较高。</span><br><span class="line"></span><br><span class="line"> <span class="number">2</span>、开发效率低：</span><br><span class="line">    应用程序一旦需要修改，必须先修改源代码，然后重新编译、生成新的目标文件才能执行，</span><br><span class="line">而在只有目标文件而没有源代码，修改会很不方便。所以开发效率低于解释型</span><br><span class="line"></span><br><span class="line"> <span class="number">3</span>、跨平台性差</span><br><span class="line">    编译型代码是针对某一个平台翻译的，当前平台翻译的结果无法拿到不同的平台使用，针对不同的平台必须重新编译，即跨平台性差</span><br><span class="line"></span><br><span class="line"> 其他</span><br><span class="line">    现在大多数的编程语言都是编译型的。</span><br><span class="line">编译程序将源程序翻译成目标程序后保存在另一个文件中，该目标程序可脱离编译程序直接在计算机上多次运行。</span><br><span class="line">大多数软件产品都是以目标程序形式发行给用户的，不仅便于直接运行，同时又使他人难于盗用其中的技术。</span><br><span class="line">C、C++、Ada、Pascal都是编译实现的</span><br></pre></td></tr></table></figure>



<h3 id="解释型-如python"><a href="#解释型-如python" class="headerlink" title="解释型(如python)"></a>解释型(如python)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>、执行效率低</span><br><span class="line">    解释型语言的实现中，翻译器并不产生目标机器代码，而是产生易于执行的中间代码。</span><br><span class="line">这种中间代码与机器代码是不同的，中间代码的解释是由软件支持的，不能直接使用硬件，</span><br><span class="line">软件解释器通常会导致执行效率较低。</span><br><span class="line"></span><br><span class="line"> <span class="number">2</span>、开发效率高</span><br><span class="line">    用解释型语言编写的程序是由另一个可以理解中间代码的解释程序执行的，与编译程序不同的是，</span><br><span class="line">解释程序的任务是逐一将源程序的语句解释成可执行的机器指令，不需要将源程序翻译成目标代码再执行。</span><br><span class="line">解释程序的优点是当语句出现语法错误时，可以立即引起程序员的注意，而程序员在程序开发期间就能进行校正。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="number">3</span>、跨平台性强</span><br><span class="line">    代码运行是依赖于解释器，不同平台有对应版本的解释器，所以解释型的跨平台性强</span><br><span class="line"></span><br><span class="line"> 其他</span><br><span class="line">    对于解释型Basic语言，需要一个专门的解释器解释执行Basic程序，每条语句只有在执行时才被翻译，</span><br><span class="line">这种解释型语言每执行一次就翻译一次，因而效率低下。一般地，动态语言都是解释型的，</span><br><span class="line">例如：Tcl、Perl、Ruby、VBScript、JavaScript等</span><br></pre></td></tr></table></figure>



<h3 id="PS-混合型语言"><a href="#PS-混合型语言" class="headerlink" title="PS(混合型语言)"></a>PS(混合型语言)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    Java是一类特殊的编程语言，Java程序也需要编译，但是却没有直接编译为机器语言，而是编译为字节码，</span><br><span class="line">然后在Java虚拟机上以解释方式执行字节码。</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、执行效率：机器语言&gt;汇编语言&gt;高级语言（编译型&gt;解释型）</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、开发效率：机器语言&lt;汇编语言&lt;高级语言（编译型&lt;解释型）</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、跨平台性：解释型具有极强的跨平台型</span><br></pre></td></tr></table></figure>



<h2 id="python介绍"><a href="#python介绍" class="headerlink" title="python介绍"></a>python介绍</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    谈及python，涉及两层意思，一层代表的是python这门语言的语法风格，另外一层代表的则是专门用来解释该语法风格的应用程序：python解释器。</span><br><span class="line"></span><br><span class="line">• python的创始人为吉多·范罗苏姆（Guido van Rossum）。Python这个名字，来自Guido所挚爱的电视剧Monty Python’s Flying Circus，他希望这个新的叫做Python的语言，能符合他的理想：创造一种C和shell之间，语法能够像shell一样简洁，易学易用、可拓展性强，同时兼顾C的强大功能。于是Guido在<span class="number">1989</span>年的圣诞节期间，开始编写能够解释Python语言语法的解释器。</span><br><span class="line"></span><br><span class="line">• Python崇尚优美、清晰、简单，是一个优秀并广泛使用的语言。最新的TIOBE排行榜https://www.tiobe.com/tiobe-index/，Python已飙升至世界第三。</span><br><span class="line"></span><br><span class="line">• Python可以应用于众多领域，如：人工智能、数据分析、爬虫、金融量化、云计算、WEB开发、自动化运维/测试、游戏开发、网络服务、图像处理等众多领域。目前业内几乎所有大中型互联网企业都在使用Python，如：Youtube、Dropbox、BT、Quora（中国知乎）、豆瓣、知乎、Google、Yahoo!、Facebook、NASA、百度、腾讯、汽车之家、美团等。</span><br></pre></td></tr></table></figure>



<h2 id="Python解释器的发展史"><a href="#Python解释器的发展史" class="headerlink" title="Python解释器的发展史"></a>Python解释器的发展史</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Granddaddy of Python web frameworks, Zope <span class="number">1</span> was released <span class="keyword">in</span> <span class="number">1999</span></span><br><span class="line"></span><br><span class="line">Python <span class="number">1.0</span> - January <span class="number">1994</span> 增加了 <span class="keyword">lambda</span>, <span class="built_in">map</span>, <span class="built_in">filter</span> <span class="keyword">and</span> reduce.</span><br><span class="line"></span><br><span class="line">Python <span class="number">2.0</span> - October <span class="number">16</span>, <span class="number">2000</span>，加入了内存回收机制，构成了现在Python语言框架的基础</span><br><span class="line"></span><br><span class="line">Python <span class="number">2.4</span> - November <span class="number">30</span>, <span class="number">2004</span>, 同年目前最流行的WEB框架Django 诞生</span><br><span class="line"></span><br><span class="line">Python <span class="number">2.5</span> - September <span class="number">19</span>, <span class="number">2006</span></span><br><span class="line"></span><br><span class="line">Python <span class="number">2.6</span> - October <span class="number">1</span>, <span class="number">2008</span></span><br><span class="line"></span><br><span class="line">Python <span class="number">2.7</span> - July <span class="number">3</span>, <span class="number">2010</span></span><br><span class="line"></span><br><span class="line">Python <span class="number">3.1</span> - June <span class="number">27</span>, <span class="number">2009</span></span><br><span class="line"></span><br><span class="line">Python <span class="number">3.2</span> - February <span class="number">20</span>, <span class="number">2011</span></span><br><span class="line"></span><br><span class="line">Python <span class="number">3.3</span> - September <span class="number">29</span>, <span class="number">2012</span></span><br><span class="line"></span><br><span class="line">Python <span class="number">3.4</span> - March <span class="number">16</span>, <span class="number">2014</span></span><br><span class="line"></span><br><span class="line">Python <span class="number">3.5</span> - September <span class="number">13</span>, <span class="number">2015</span></span><br><span class="line"></span><br><span class="line">Python <span class="number">3.6</span> - <span class="number">2016</span>-<span class="number">12</span>-<span class="number">23</span> 发布python3<span class="number">.6</span><span class="number">.0</span>版</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/11/12/%E8%A3%85%E9%A5%B0%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="池劲涛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="池劲涛的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/12/%E8%A3%85%E9%A5%B0%E5%99%A8/" class="post-title-link" itemprop="url">装饰器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-12 07:20:25" itemprop="dateCreated datePublished" datetime="2018-11-12T07:20:25+08:00">2018-11-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-12-01 12:22:34" itemprop="dateModified" datetime="2018-12-01T12:22:34+08:00">2018-12-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Python系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h1><ul>
<li>装饰器介绍</li>
<li>装饰器的实现</li>
</ul>
<h1 id="内容详细："><a href="#内容详细：" class="headerlink" title="内容详细："></a>内容详细：</h1><h1 id="装饰器介绍"><a href="#装饰器介绍" class="headerlink" title="装饰器介绍"></a>装饰器介绍</h1><h2 id="为何要用装饰器"><a href="#为何要用装饰器" class="headerlink" title="为何要用装饰器"></a>为何要用装饰器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">软件的设计应该遵循开放封闭原则，即对扩展是开放的，而对修改是封闭的</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对扩展开放：意味着有新的需求或变化时，可以对现有的代码进行扩展，以适应新的情况</span></span><br><span class="line"><span class="comment"># 对修改封闭：意味着对象一旦设计完成，就可以独立完成其工作，而不要对其进行修改</span></span><br><span class="line"></span><br><span class="line">软件包含的所有的功能的源代码以及调用方式，都应该避免修改，否则一旦改错，极有可能产生连锁反应，最终导致程序崩溃，而对于上线后的软件，新需求或者变化又层出不穷，我们必须为程序提供扩展的可能性，这就用到了装饰器</span><br></pre></td></tr></table></figure>

<h2 id="什么是装饰器"><a href="#什么是装饰器" class="headerlink" title="什么是装饰器"></a>什么是装饰器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;装饰&#x27;</span>:代指为被装饰对象添加新的功能</span><br><span class="line"><span class="string">&#x27;器&#x27;</span>:代指器具/工具</span><br><span class="line">装饰器与被装饰的对象均可以是任意可调用对象</span><br><span class="line"></span><br><span class="line"><span class="comment"># 概括的讲，装饰器的作用就是：在不修改被装饰对象源代码和调用方式的前提下 ---&gt; 为被装饰对象添加额外的功能</span></span><br><span class="line"></span><br><span class="line">装饰器经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等应用场景</span><br><span class="line">装饰器是解决这类问题的绝佳设计，有了装饰器，就可以抽离出大量与函数功能本身无关的雷同代码并继续重用</span><br><span class="line"></span><br><span class="line">ps：可调用对象有函数、方法或者类</span><br></pre></td></tr></table></figure>

<h1 id="装饰器的实现"><a href="#装饰器的实现" class="headerlink" title="装饰器的实现"></a>装饰器的实现</h1><p><strong>函数装饰器分为：’无参装饰器’和’有参装饰器’两种，二者的实现原理一样，都是’函数嵌套+闭包+函数对象’的组合使用的产物</strong></p>
<h2 id="无参装饰器的实现"><a href="#无参装饰器的实现" class="headerlink" title="无参装饰器的实现"></a>无参装饰器的实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如果想为下述函数添加统计其执行时间的功能</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Welcome to the index page’)</span></span><br><span class="line"><span class="string">    return 200</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">index() #函数执行</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">遵循不修改被装饰对象源代码的原则，我们想到的解决方法可能是这样：</span><br><span class="line"></span><br><span class="line">strat_time = time.time()</span><br><span class="line">index() <span class="comment"># 函数执行</span></span><br><span class="line">stop_time = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;run time is %s&#x27;</span> %(stop_time-start_time))  </span><br><span class="line">考虑到还有可能要统计其他函数的执行时间，于是我们将其做成一个单独的工具，函数体需要外部传入被装饰的函数从而进行调用，我们可以使用参数的形式传入</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">func</span>):</span> <span class="comment"># 通过参数接收外部的值</span></span><br><span class="line">    start_time=time.time()</span><br><span class="line">    res=func()</span><br><span class="line">    stop_time=time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;run time is %s&#x27;</span> %(stop_time-start_time))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">但之后函数的调用方式都需要统一改成：</span><br><span class="line">wrapper(index)</span><br><span class="line">wrapper(其他函数)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">========================================================================================</span><br><span class="line"></span><br><span class="line">但这就违反了不能修改被装饰对象调用方式的原则，于是我们换一种为函数体传值的方式，即将值包给函数，如下：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>():</span> <span class="comment"># 引用外部作用域的变量func</span></span><br><span class="line">        start_time=time.time()</span><br><span class="line">        res=func()</span><br><span class="line">        stop_time=time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;run time is %s&#x27;</span> %(stop_time-start_time))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper   </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这样我们便可以在不修改被装饰函数源代码和调用方式的前提下，为其添加上统计时间的功能，只不过需要事先执行一次timer将被装饰的函数传入，返回一个闭包函数wrapper重新赋值给变量名/函数名index 如下：</span><br><span class="line"></span><br><span class="line">index = timer(index) <span class="comment"># 得到index = wrapper，wrapper携带对外作用域的引用：func = 原始的index</span></span><br><span class="line">index() <span class="comment"># 执行的是wrapper(),在wrapper的函数体内再执行最原始的index</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">========================================================================================</span><br><span class="line"></span><br><span class="line">至此我们便实现了一个无参装饰器timer，可以在不修改被装饰对象index源代码和调用方式的前提下为其加上新功能</span><br><span class="line">但我们忽略了若被装饰的函数是一个有参函数，便会抛出异常</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>(<span class="params">name</span>):</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Welcome to the home page&#x27;</span>,name)</span><br><span class="line"></span><br><span class="line">home=timer(home)</span><br><span class="line">home(<span class="string">&#x27;egon&#x27;</span>)</span><br><span class="line"><span class="comment">#抛出异常</span></span><br><span class="line">TypeError: wrapper() takes <span class="number">0</span> positional arguments but <span class="number">1</span> was given</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">========================================================================================</span><br><span class="line"> </span><br><span class="line">之所以会抛出异常，是因为home(<span class="string">&#x27;egon&#x27;</span>)调用的其实是wrapper(<span class="string">&#x27;egon&#x27;</span>),而函数wrapper没有参数</span><br><span class="line">wrapper函数接收的参数其实是给最原始的func用的，为了能满足被装饰函数参数的所有情况</span><br><span class="line">要使用：*args + **kwargs的组合，于是 ---&gt; 最终版装饰器timer如下：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        start_time=time.time()</span><br><span class="line">        res=func(*args,**kwargs)</span><br><span class="line">        stop_time=time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;run time is %s&#x27;</span> %(stop_time-start_time))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper   </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">此时我们就可以用timer来装饰带参数或不带参数的函数了，但是为了简洁而优雅地使用装饰器</span><br><span class="line">python提供了专门的装饰器语法来取代index = timer(index)的形式</span><br><span class="line">        <span class="comment"># 需要在被装饰对象的正上方单独一行添加@timer</span></span><br><span class="line">当解释器解释到@timer时就会调用timer函数，且把它正下方的函数名当做实参传入，然后将返回的结果重新赋值给原函数名</span><br><span class="line">          </span><br><span class="line"><span class="meta">@timer </span><span class="comment"># index=timer(index)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Welcome to the index page&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span></span><br><span class="line"><span class="meta">@timer </span><span class="comment"># index=timer(home)•          def home(name):</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Welcome to the home page’,name)</span></span><br><span class="line"><span class="string">如果我们有多个装饰器，可以叠加多个</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@deco3</span></span><br><span class="line"><span class="string">@deco2</span></span><br><span class="line"><span class="string">@deco1</span></span><br><span class="line"><span class="string">def index():</span></span><br><span class="line"><span class="string">    pass</span></span><br><span class="line"><span class="string">叠加多个装饰器也无特殊之处，上述代码语义如下：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">index=deco3(deco2(deco1(index)))    </span></span><br></pre></td></tr></table></figure>

<h2 id="有参装饰器的实现"><a href="#有参装饰器的实现" class="headerlink" title="有参装饰器的实现"></a>有参装饰器的实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在了解了无参装饰器的实现原理之后，我们可以再实现一个用来为被装饰对象添加认证功能的装饰器，实现的基本形式如下：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        编写基于文件的认证,认证通过则执行res=func(*args,**kwargs),并返回res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">如果我们想提供多种不同的认证方式以供选择，单从wrapper函数的实现角度改写如下</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">            <span class="keyword">if</span> driver == <span class="string">&#x27;file&#x27;</span>:</span><br><span class="line">                编写基于文件的认证,认证通过则执行res=func(*args,**kwargs),并返回res</span><br><span class="line">            <span class="keyword">elif</span> driver == <span class="string">&#x27;mysql&#x27;</span>:</span><br><span class="line">                编写基于mysql认证,认证通过则执行res=func(*args,**kwargs),并返回res</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数wrapper需要一个driver参数，而函数deco与wrapper的参数都有其特定的功能，不能用来接受其他类别的参数，可以再deco的外部再包一层函数auth，用来专门接受额外的参数，这样便保证了再auth函数内无论多少层都可以引用到</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span>(<span class="params">driver</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deco</span>(<span class="params">func</span>):</span></span><br><span class="line">        ……</span><br><span class="line">    <span class="keyword">return</span> deco</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">此时我们就实现了一个有参装饰器，使用方式如下</span><br><span class="line"></span><br><span class="line">先调用auth_type(driver=<span class="string">&#x27;file&#x27;</span>)，得到@deco，deco是一个闭包函数，</span><br><span class="line">包含了对外部作用域名字driver的引用，@deco的语法意义与无参装饰器一样</span><br><span class="line"><span class="meta">@auth(<span class="params">driver=<span class="string">&#x27;file&#x27;</span></span>) </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span>     </span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">@auth(<span class="params">driver=<span class="string">&#x27;mysql&#x27;</span></span>) </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>():</span></span><br><span class="line">    <span class="keyword">pass</span>  </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以使用<span class="built_in">help</span>(函数名)来查看函数的文档注释，本质就是查看函数的doc属性，但对于被装饰之后的函数，查看文档注释</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    home page function</span></span><br><span class="line"><span class="string">    :param name: str</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Welcome to the home page&#x27;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">help</span>(home))</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"></span><br><span class="line">Help on function wrapper <span class="keyword">in</span> module __main__:</span><br><span class="line"></span><br><span class="line">wrapper(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在被装饰之后home=wrapper,查看home.name也可以发现home的函数名确实是wrapper，想要保留原函数的文档和函数名属性，需要修正装饰器</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        start_time=time.time()</span><br><span class="line">        res=func(*args,**kwargs)</span><br><span class="line">        stop_time=time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;run time is %s&#x27;</span> %(stop_time-start_time))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    wrapper.__doc__=func.__doc__</span><br><span class="line">    wrapper.__name__=func.__name__</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">按照上述方式来实现保留原函数属性过于麻烦，functools模块下提供一个装饰器wraps专门用来帮我们实现这件事，用法如下</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        start_time=time.time()</span><br><span class="line">        res=func(*args,**kwargs)</span><br><span class="line">        stop_time=time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;run time is %s&#x27;</span> %(stop_time-start_time))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/11/12/%E7%94%9F%E6%88%90%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="池劲涛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="池劲涛的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/12/%E7%94%9F%E6%88%90%E5%99%A8/" class="post-title-link" itemprop="url">生成器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-12 07:20:25" itemprop="dateCreated datePublished" datetime="2018-11-12T07:20:25+08:00">2018-11-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-12-01 12:22:34" itemprop="dateModified" datetime="2018-12-01T12:22:34+08:00">2018-12-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Python系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h1><ul>
<li>生成器与yield</li>
<li>yield表达式应用</li>
<li>三元表达式、列表生成式、生成器表达式</li>
</ul>
<h1 id="内容详细"><a href="#内容详细" class="headerlink" title="内容详细"></a>内容详细</h1><h2 id="生成器与yield"><a href="#生成器与yield" class="headerlink" title="生成器与yield"></a>生成器与yield</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">若函数体包含<span class="keyword">yield</span>关键字，再调用函数，并不会执行函数体代码，得到的返回值即生成器对象</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">my_range</span>(<span class="params">start,stop,step=<span class="number">1</span></span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;start...&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> start &lt; stop:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">yield</span> start</span><br><span class="line"><span class="meta">... </span>        start+=step</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;end...&#x27;</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g=my_range(<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator <span class="built_in">object</span> my_range at <span class="number">0x104105678</span>&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">生成器内置有__iter__和__next__方法，所以生成器本身就是一个迭代器</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.__iter__</span><br><span class="line">&lt;method-wrapper <span class="string">&#x27;__iter__&#x27;</span> of generator <span class="built_in">object</span> at <span class="number">0x1037d2af0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.__next__</span><br><span class="line">&lt;method-wrapper <span class="string">&#x27;__next__&#x27;</span> of generator <span class="built_in">object</span> at <span class="number">0x1037d2af0</span>&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">所以我们可以用<span class="built_in">next</span>(生成器)触发生成器所对应函数的执行</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g) <span class="comment"># 触发函数执行直到遇到yield则停止,将yield后的值返回，并在当前位置挂起函数</span></span><br><span class="line">start...</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g) <span class="comment"># 再次调用next(g)，函数从上次暂停的位置继续执行，直到重新遇到yield...</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g) <span class="comment"># 周而复始...</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g) <span class="comment"># 触发函数执行没有遇到yield则无值返回，即取值完毕抛出异常结束迭代</span></span><br><span class="line">end...</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">既然生成器对象属于迭代器，那么必然可以使用<span class="keyword">for</span>循环迭代：</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> countdown(<span class="number">3</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">countdown start</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">Done!</span><br></pre></td></tr></table></figure>

<p><strong>有了yield关键字，我们就有了一种自定义迭代器的实现方式</strong><br><strong>yield可以用于返回值，但不同于return，函数一旦遇到return就结束了，而yield则可以保存函数的运行状态并挂起函数，用来返回多次值</strong></p>
<h2 id="yield表达式应用"><a href="#yield表达式应用" class="headerlink" title="yield表达式应用"></a>yield表达式应用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在函数内可以采用表达式形式的<span class="keyword">yield</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eater</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ready to eat&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        food = <span class="keyword">yield</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get the food: %s, and start to eat&#x27;</span> % food)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">可以拿到函数的生成器对象持续为函数体send值：</span><br><span class="line"></span><br><span class="line">g = eater() <span class="comment"># 得到生成器对象</span></span><br><span class="line">g</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;generator <span class="built_in">object</span> eater at <span class="number">0x101b6e2b0</span>&gt;</span><br><span class="line"><span class="built_in">next</span>(g) <span class="comment"># 需要事先&#x27;初始化&#x27;一次，让函数挂起在food = yield，等待调用g.send()方法为其传值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ready to eat</span><br><span class="line">g.send(<span class="string">&#x27;包子&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get the food: 包子, <span class="keyword">and</span> start to eat</span><br><span class="line">g.send(<span class="string">&#x27;鸡腿&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get the food: 鸡腿, <span class="keyword">and</span> start to eat</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">针对表达式形式的yield，生成器对象必须事先被初始化一次，让函数挂起在food = yield的位置，等待调用g.send()方法为函数体传值，g.send(None)等同于next(g)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">• 我们可以编写装饰器来完成为所有表达式形式<span class="keyword">yield</span>对应生成器的初始化操作，如下</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        g=func(*args,**kwargs)</span><br><span class="line">        <span class="built_in">next</span>(g)</span><br><span class="line">        <span class="keyword">return</span> g</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@init</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eater</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Ready to eat&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        food=<span class="keyword">yield</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;get the food: %s, and start to eat&#x27;</span> %food)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">表达式形式的<span class="keyword">yield</span>也可以用于返回多次值，即变量名=<span class="keyword">yield</span> 值的形式，如下</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">eater</span>():</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&#x27;Ready to eat&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>    food_list=[]</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>        food=<span class="keyword">yield</span> food_list</span><br><span class="line"><span class="meta">... </span>        food_list.append(food)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e=eater()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(e)</span><br><span class="line">Ready to eat</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.send(<span class="string">&#x27;蒸羊羔&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;蒸羊羔&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.send(<span class="string">&#x27;蒸熊掌&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;蒸羊羔&#x27;</span>, <span class="string">&#x27;蒸熊掌&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e.send(<span class="string">&#x27;蒸鹿尾儿&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;蒸羊羔&#x27;</span>, <span class="string">&#x27;蒸熊掌&#x27;</span>, <span class="string">&#x27;蒸鹿尾儿&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="三元表达式、列表生成式、生成器表达式"><a href="#三元表达式、列表生成式、生成器表达式" class="headerlink" title="三元表达式、列表生成式、生成器表达式"></a>三元表达式、列表生成式、生成器表达式</h2><h3 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">三元表达式是python为我们提供的一种简化代码的解决方案，语法如下：</span><br><span class="line"></span><br><span class="line"><span class="comment"># res = 条件成立时返回的值 if 条件 else 条件不成立时返回的值</span></span><br><span class="line"></span><br><span class="line">针对下述场景：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max2</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; y:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line">res = max2(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">用三元表达式可以一行解决</span><br><span class="line"></span><br><span class="line">x=<span class="number">1</span></span><br><span class="line">y=<span class="number">2</span></span><br><span class="line"><span class="comment"># res = x if x &gt; y else y # 三元表达式 </span></span><br></pre></td></tr></table></figure>

<h3 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">列表生成式是python为我们提供的一种简化代码的解决方案，用来快速生成列表，语法如下：</span><br><span class="line"></span><br><span class="line">[expression <span class="keyword">for</span> item1 <span class="keyword">in</span> iterable1 <span class="keyword">if</span> condition1</span><br><span class="line"><span class="keyword">for</span> item2 <span class="keyword">in</span> iterable2 <span class="keyword">if</span> condition2</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> itemN <span class="keyword">in</span> iterableN <span class="keyword">if</span> conditionN</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">#类似于</span></span><br><span class="line">res=[]</span><br><span class="line"><span class="keyword">for</span> item1 <span class="keyword">in</span> iterable1:</span><br><span class="line">    <span class="keyword">if</span> condition1:</span><br><span class="line">        <span class="keyword">for</span> item2 <span class="keyword">in</span> iterable2:</span><br><span class="line">            <span class="keyword">if</span> condition2</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">for</span> itemN <span class="keyword">in</span> iterableN:</span><br><span class="line">                    <span class="keyword">if</span> conditionN:</span><br><span class="line">                        res.append(expression)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">针对下述场景：</span><br><span class="line"></span><br><span class="line">egg_list=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    egg_list.append(<span class="string">&#x27;鸡蛋%s&#x27;</span> %i)</span><br><span class="line">用列表生成式可以一行解决</span><br><span class="line"></span><br><span class="line"><span class="comment"># egg_list=[&#x27;鸡蛋%s&#x27; %i for i in range(10)]</span></span><br></pre></td></tr></table></figure>

<h3 id="生成式表达式"><a href="#生成式表达式" class="headerlink" title="生成式表达式"></a>生成式表达式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">创建一个生成器对象有两种方式：</span><br><span class="line"><span class="number">1</span> 调用带<span class="keyword">yield</span>关键字的函数</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 生成器表达式 ---&gt; 与列表生成式的语法格式相同，只需要将[]换成()即可：</span><br><span class="line">    （expression <span class="keyword">for</span> item <span class="keyword">in</span> iterable <span class="keyword">if</span> condition）</span><br><span class="line">    </span><br><span class="line">对比列表生成式返回的是一个列表，生成器表达式返回的是一个生成器对象</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g=(x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x101be0ba0</span>&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">对比列表生成式，生成器表达式的优点自然是节省内存（一次只产生一个值在内存中）</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g) <span class="comment">#抛出异常StopIteration</span></span><br><span class="line">如果我们要读取一个大文件的字节数，应该基于生成器表达式的方式完成</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;db.txt&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    nums=(<span class="built_in">len</span>(line) <span class="keyword">for</span> line <span class="keyword">in</span> f)</span><br><span class="line">    total_size=<span class="built_in">sum</span>(nums) <span class="comment"># 依次执行next(nums)，然后累加到一起得到结果= </span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="池劲涛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="池劲涛的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">计算机核心基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-12 07:20:25" itemprop="dateCreated datePublished" datetime="2018-11-12T07:20:25+08:00">2018-11-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-12-01 12:22:34" itemprop="dateModified" datetime="2018-12-01T12:22:34+08:00">2018-12-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Python系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><h2 id="什么是语言？什么是编程语言？为什么要有编程语言"><a href="#什么是语言？什么是编程语言？为什么要有编程语言" class="headerlink" title="什么是语言？什么是编程语言？为什么要有编程语言?"></a>什么是语言？什么是编程语言？为什么要有编程语言?</h2><h2 id="什么是编程？为什么要编程？"><a href="#什么是编程？为什么要编程？" class="headerlink" title="什么是编程？为什么要编程？"></a>什么是编程？为什么要编程？</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.1</span> </span><br><span class="line">    <span class="number">1</span> 语言就是人与人之间沟通的介质(英语、汉语...)</span><br><span class="line">    <span class="number">2</span> 编程语言就是人与计算机之间沟通的介质</span><br><span class="line">    <span class="number">3</span> 为什么要有编程语言，或者说人为什么要与计算机沟通呢？这是因为在编程的世界里，计算机就好比是人的奴隶，人与计算机沟通的目的就是为了奴役计算机，让计算机按照人类的思维逻辑自发地去工作从而把人力解放出来。</span><br><span class="line"><span class="number">1.2</span></span><br><span class="line">    <span class="number">1</span> 编程就是人把自己想命令计算机干的事用编程语言翻译出来并写到文件里(这一系列的文件就是程序)</span><br><span class="line">    <span class="number">2</span> 分为两个层面</span><br><span class="line">        -为了更好的控制人类的奴隶(计算机)，我们需要学习计算机是由什么组成的、它能做什么、它是怎样工作的</span><br><span class="line">        -我们需要学习编程语言，从而把原来需要人力来完成的业务(ATM+购物)交给计算机去做</span><br></pre></td></tr></table></figure>

<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="什么是计算机？"><a href="#什么是计算机？" class="headerlink" title="什么是计算机？"></a>什么是计算机？</h2><p><strong>俗称电脑，即通电的大脑，电脑二字蕴含了人类对计算机的终极期望，希望它能真的像人脑一样去工作，从而解放人力。</strong></p>
<p><strong>懒人奴役的是真正的人，而人是无法不吃、不喝、不睡觉一直工作的，但是计算机作为一台机器是可以做到的，所以把计算机当奴隶是上上之选。</strong></p>
<p><strong>世界是由聪明的懒人统治的，任何时期，总有一群聪明的懒人想要奴隶别人。在奴隶制社会，聪明的懒人奴役的是真正的人，而人是无法不吃、不喝、不睡觉一直工作的，但是计算机作为一台机器是可以做到的，所以把计算机当奴隶是上上之选。</strong></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="计算机的五大组成部分"><a href="#计算机的五大组成部分" class="headerlink" title="计算机的五大组成部分"></a>计算机的五大组成部分</h2><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p><strong>控制器是计算机的指挥系统，用来控制计算机其他组件的运行，相当于人类的大脑</strong></p>
<h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><p><strong>运算器是计算机的运算功能，用来做算术运算和逻辑运算，相当于人脑。<br>PS：控制器 + 运算器 = CPU</strong></p>
<h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><p><strong>存储器是计算机的记忆功能，用来存取数据。</strong></p>
<p><strong>存储器主要分为内存与外存：</strong></p>
<p><strong>内存相当于人的短期记忆。断电数据丢失</strong></p>
<p><strong>外存(如磁盘),相当于记事的本子，断电数据不会丢失，是用来永久保存数据的</strong></p>
<p><strong>ps：内存的存取速度要远远高于外存</strong></p>
<h3 id="输入设备input"><a href="#输入设备input" class="headerlink" title="输入设备input"></a>输入设备input</h3><p><strong>输入设备是计算接收外界输入数据的工具，如键盘、鼠标，相当于人的眼睛或耳朵。</strong></p>
<h3 id="输出设备output"><a href="#输出设备output" class="headerlink" title="输出设备output"></a>输出设备output</h3><p><strong>输出设备是计算机向外输出数据的工具，如显示器、打印机，相当于人说的话，写出的文章。</strong></p>
<p><strong>ps：存储器如内存、磁盘等既是输入设备又是输出设备，统称为IO设备</strong></p>
<h1 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h1><h2 id="操作系统的由来"><a href="#操作系统的由来" class="headerlink" title="操作系统的由来"></a>操作系统的由来</h2><p><strong>大前提：我们编程目的就是为了奴役计算机，让计算机硬件自发地运行起来，然而硬件毕竟是”死的“，硬件的运行都是由软件支配。</strong></p>
<p><strong>倘若我们要开发一个应用程序，比如暴风音影，该软件的一个核心业务就是播放视频，开发者若要编写程序完成播放视频这个业务逻辑，必先涉及到底层硬件硬盘的基本运作（视频文件都是先存放于硬盘中），这意味着开发者在编写业务逻辑代码之前，必须先编写一个控制硬盘基本运行的控制程序，然而这仅仅只是一个开始，事实上，在编写应用程序的业务逻辑前，需要开发者编写出一套完整的控制程序用来控制所有硬件的基本运行（这要求开发者需要详细了解计算机硬件的各种控制细节，例如我们必须把CPU里面所有指令集都掌握一遍），如此，所有的开发者在开发程序时都必须依次开发两种：</strong><br>　　<strong>1、编写一套完整的的控制程序，用来控制硬件的基本运行，以及把复杂的硬件的操作封装成简单的接口</strong><br>　　<strong>2、基于控制程序的接口开发包含一系列业务逻辑的程序，为了与控制程序区分，可以称为应用程序，以ATM这款应用程序为例，业务逻辑有提款、转账、查询余额等</strong><br><strong>综上，对于不同公司的开发者来说，应用程序的业务逻辑各不相同，但硬件的控制程序都大致相同，为了避免所有程序员做重复劳动，以及不用再耗费精力去了解所有硬件的运行细节，有公司专门跳出来承担起控制程序的开发任务，这里所说的控制程序指的就是操作系统。</strong></p>
<p><strong>操作系统的功能就是帮我们把复杂的硬件的控制封装成简单的接口，对于开发应用程序来说只需要调用操作系统提供给我们的接口即可</strong></p>
<h2 id="系统软件与应用软件"><a href="#系统软件与应用软件" class="headerlink" title="系统软件与应用软件"></a>系统软件与应用软件</h2><p><strong>硬件以上运行的都是软件，而软件分为两类：</strong><br>    <strong>一、应用软件（例如qq、word、暴风影音，我们学习python就是为了开发应用软件的）</strong></p>
<p>​    <strong>二、操作系统，操作系统应用软件与硬件之间的一个桥梁，是协调、管理、控制计算机硬件与应用软件资源的控制程序。</strong></p>
<h2 id="计算机系统的三层结构"><a href="#计算机系统的三层结构" class="headerlink" title="计算机系统的三层结构"></a>计算机系统的三层结构</h2><p><img src="https://img2020.cnblogs.com/blog/2342210/202104/2342210-20210421171214070-1978353069.png" alt="img"></p>
<h3 id="一个非常重要的基础概念：平台"><a href="#一个非常重要的基础概念：平台" class="headerlink" title="一个非常重要的基础概念：平台"></a>一个非常重要的基础概念：平台</h3><p><strong>应用程序都是运行于操作系统之上，而操作系统则是运行于硬件之上的，所以承载应用程序的是一台运行有操作系统的计算机，称之为应用程序的运行平台，即：硬件 + 操作系统 == 平台</strong><br><strong>常见的平台有：windows系统+某款硬件、linux系统+某款硬件、ubuntu+某款硬件等，我们在开发应用程序时就需要考虑到应用程序的跨平台性，如果能开发出一款可以在任意平台运行的应用程序，那对于开发者来说真是极大的福音。而决定应用软件的跨平台性的关键因素往往是编程语言的选择，python恰好是一款跨平台性语言，这也是我们学习它的原因之一。</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/2342210/202104/2342210-20210421171226105-104347706.png" alt="img"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/11/12/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="池劲涛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="池劲涛的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/12/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9B%AE%E5%BD%95%E8%A7%84%E8%8C%83/" class="post-title-link" itemprop="url">软件开发目录规范</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-12 07:20:25" itemprop="dateCreated datePublished" datetime="2018-11-12T07:20:25+08:00">2018-11-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-12-01 12:22:34" itemprop="dateModified" datetime="2018-12-01T12:22:34+08:00">2018-12-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Python系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h1><ul>
<li>软件开发目录规范</li>
</ul>
<h1 id="内容详细"><a href="#内容详细" class="headerlink" title="内容详细"></a>内容详细</h1><h2 id="软件开发目录规范"><a href="#软件开发目录规范" class="headerlink" title="软件开发目录规范"></a>软件开发目录规范</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">为了提高程序的可读性与可维护性，我们应该为软件设计良好的目录结构，这与规范的编码风格同等重要。软件的目录规范并无硬性标准，只要清晰可读即可，假设你的软件名为foo，笔者推荐目录结构如下</span><br><span class="line"></span><br><span class="line">Foo/</span><br><span class="line">|-- core/</span><br><span class="line">|   |-- core.py</span><br><span class="line">|</span><br><span class="line">|-- api/</span><br><span class="line">|   |-- api.py</span><br><span class="line">|</span><br><span class="line">|-- db/</span><br><span class="line">|   |-- db_handle.py</span><br><span class="line">|</span><br><span class="line">|-- lib/</span><br><span class="line">|   |-- common.py</span><br><span class="line">|</span><br><span class="line">|-- conf/</span><br><span class="line">|   |-- settings.py</span><br><span class="line">|</span><br><span class="line">|-- run.py</span><br><span class="line">|-- setup.py</span><br><span class="line">|-- requirements.txt</span><br><span class="line">|-- README</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">简要解释一下:</span><br><span class="line"></span><br><span class="line"> • core/: 存放业务逻辑相关代码</span><br><span class="line"></span><br><span class="line"> • api/: 存放接口文件，接口主要用于为业务逻辑提供数据操作。</span><br><span class="line"></span><br><span class="line"> • db/: 存放操作数据库相关文件，主要用于与数据库交互</span><br><span class="line"></span><br><span class="line"> • lib/: 存放程序中常用的自定义模块</span><br><span class="line"></span><br><span class="line"> • conf/: 存放配置文件</span><br><span class="line"></span><br><span class="line"> • run.py: 程序的启动文件，一般放在项目的根目录下，因为在运行时会默认将运行文件所在的文件夹作为sys.path的第一个路径，这样就省去了处理环境变量的步骤</span><br><span class="line"></span><br><span class="line"> • setup.py: 安装、部署、打包的脚本。</span><br><span class="line"></span><br><span class="line"> • requirements.txt: 存放软件依赖的外部Python包列表。</span><br><span class="line"></span><br><span class="line"> • README: 项目说明文件。</span><br><span class="line"></span><br><span class="line">除此之外，有一些方案给出了更加多的内容，比如LICENSE.txt,ChangeLog.txt文件等，主要是在项目需要开源时才会用到，请读者自行查阅。</span><br><span class="line"></span><br><span class="line">关于README的内容，这个应该是每个项目都应该有的一个文件，目的是能简要描述该项目的信息，让读者快速了解这个项目。它需要说明以下几个事项:</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、软件定位，软件的基本功能；</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、运行代码的方法: 安装环境、启动命令等；</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、简要的使用说明；</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、代码目录结构说明，更详细点可以说明软件的基本原理；</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、常见问题说明。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关于setup.py和requirements.txt：</span><br><span class="line"></span><br><span class="line">一般来说，用setup.py来管理代码的打包、安装、部署问题。业界标准的写法是用Python流行的打包工具setuptools来管理这些事情，这种方式普遍应用于开源项目中。不过这里的核心思想不是用标准化的工具来解决这些问题，而是说，一个项目一定要有一个安装部署工具，能快速便捷的在一台新机器上将环境装好、代码部署好和将程序运行起来。</span><br><span class="line"></span><br><span class="line">requirements.txt文件的存在是为了方便开发者维护软件的依赖库。我们需要将开发过程中依赖库的信息添加进该文件中，避免在 setup.py安装依赖时漏掉软件包，同时也方便了使用者明确项目引用了哪些Python包。</span><br><span class="line"></span><br><span class="line">这个文件的格式是每一行包含一个包依赖的说明，通常是flask&gt;=<span class="number">0.10</span>这种格式，要求是这个格式能被pip识别，这样就可以简单的通过 pip install -r requirements.txt来把所有Python依赖库都装好了</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/11/12/%E8%BF%AD%E4%BB%A3%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="池劲涛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="池劲涛的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/12/%E8%BF%AD%E4%BB%A3%E5%99%A8/" class="post-title-link" itemprop="url">迭代器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-12 07:20:25" itemprop="dateCreated datePublished" datetime="2018-11-12T07:20:25+08:00">2018-11-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-12-01 12:22:34" itemprop="dateModified" datetime="2018-12-01T12:22:34+08:00">2018-12-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Python系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h1><ul>
<li>迭代器介绍</li>
<li>for循环原理</li>
<li>迭代器的优缺点</li>
</ul>
<h1 id="内容详细"><a href="#内容详细" class="headerlink" title="内容详细"></a>内容详细</h1><h2 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">迭代器即用来迭代取值的工具，而迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果</span><br><span class="line">每一次对工程的重复称为一次<span class="string">&#x27;迭代&#x27;</span>，而每一次迭代得到的结果会作为下一次迭代的初始值，单纯的重复并不是迭代</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = <span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">    <span class="built_in">print</span>(msg)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">下述<span class="keyword">while</span>循环才是一个迭代的过程，不仅满足重复，而且<span class="string">&#x27;每次重新赋值后的index值作为下一次循环中新的索引进行取值，反复迭代，最终可以取尽列表中的值&#x27;</span></span><br><span class="line"></span><br><span class="line">goods = [<span class="string">&#x27;mac&#x27;</span>, <span class="string">&#x27;lenovo&#x27;</span>, <span class="string">&#x27;acer&#x27;</span>, <span class="string">&#x27;dell&#x27;</span>, <span class="string">&#x27;sony&#x27;</span>]</span><br><span class="line"></span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> index &lt; <span class="built_in">len</span>(goods):</span><br><span class="line">    <span class="built_in">print</span>(goods[index])</span><br><span class="line">    index += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">通过索引的方式进行迭代取值，实现简单，但仅适用于序列类型：字符串、列表、元组</span><br><span class="line">但对于没有索引的字典、集合等非序列类型，必须找到一种不依赖索引来进行迭代取值的方式，这就用到了<span class="string">&#x27;迭代器&#x27;</span></span><br><span class="line"></span><br><span class="line">想了解迭代器是什么，必须事先搞清楚一个很重要的概念：可迭代对象</span><br><span class="line"></span><br><span class="line">从语法形式上讲，内置有__inter__方法的对象都是可迭代对象，字符串、列表、元组、字典、集合、打开的文件都是可迭代对象：</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;egon&#x27;</span>&#125;.__iter__</span><br><span class="line">&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;.__iter__</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h3 id="迭代器对象"><a href="#迭代器对象" class="headerlink" title="迭代器对象"></a>迭代器对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">调用obj.<span class="built_in">iter</span>()方法返回的结果就是一个<span class="string">&#x27;迭代器对象&#x27;</span></span><br><span class="line">迭代器对象是内置有<span class="built_in">iter</span>和<span class="built_in">next</span>方法的对象，打开的文件本身就是一个迭代器对象，执行迭代器对象.<span class="built_in">iter</span>()方法得到的仍然是迭代器本身，而执行迭代器.<span class="built_in">next</span>()方法就会计算出迭代器的下一个值</span><br><span class="line">迭代器是python提供的一种统一的、不依赖索引的迭代取值方式，只要存在多个<span class="string">&#x27;值&#x27;</span>，无论序列类型还是非序列类型都可以按照迭代器的方式取值</span><br><span class="line"></span><br><span class="line">s = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment"># 可迭代对象</span></span><br><span class="line">i = <span class="built_in">iter</span>(s) <span class="comment"># 本质就是在调用s.__iter__(),返回s的迭代器对象i</span></span><br><span class="line"><span class="built_in">next</span>(i) <span class="comment"># 本质就是在调用i.__next__()</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span></span><br><span class="line"><span class="built_in">next</span>(i)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="built_in">next</span>(i)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span></span><br><span class="line"><span class="built_in">next</span>(i)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 抛出stopiteration的异常，代表无值可取，迭代结束 </span></span><br></pre></td></tr></table></figure>

<h2 id="for循环原理"><a href="#for循环原理" class="headerlink" title="for循环原理"></a>for循环原理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">有了迭代器之后 我们便可以不依赖索引迭代取值了，使用<span class="keyword">while</span>循环的实现方式如下：</span><br><span class="line"></span><br><span class="line">goods=[<span class="string">&#x27;mac&#x27;</span>,<span class="string">&#x27;lenovo&#x27;</span>,<span class="string">&#x27;acer&#x27;</span>,<span class="string">&#x27;dell&#x27;</span>,<span class="string">&#x27;sony&#x27;</span>]</span><br><span class="line">i=<span class="built_in">iter</span>(goods) <span class="comment">#每次都需要重新获取一个迭代器对象</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">next</span>(i))</span><br><span class="line">    <span class="keyword">except</span> StopIteration: <span class="comment">#捕捉异常终止循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>循环又称为迭代循环，<span class="keyword">in</span>后可以跟任意可迭代对象，上述<span class="keyword">while</span>循环可以简写为：</span><br><span class="line"></span><br><span class="line">goods=[<span class="string">&#x27;mac&#x27;</span>,<span class="string">&#x27;lenovo&#x27;</span>,<span class="string">&#x27;acer&#x27;</span>,<span class="string">&#x27;dell&#x27;</span>,<span class="string">&#x27;sony&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> goods:   </span><br><span class="line">    <span class="built_in">print</span>(item)</span><br></pre></td></tr></table></figure>

<p><strong>for循环在工作时，首先会调用可迭代对象goods内置的iter方法拿到一个迭代器对象，然后再调用该迭代器对象的next方法将取到的值赋给item，执行循环体完成一次循环，周而复始，直到捕捉stopiteration异常，结束迭代</strong></p>
<h2 id="迭代器的优缺点"><a href="#迭代器的优缺点" class="headerlink" title="迭代器的优缺点"></a>迭代器的优缺点</h2><p> <strong>基于索引的迭代取值，所有迭代的状态都保存在了索引中，而基于迭代器实现迭代的方式不再需要索引，所有迭代的状态就保存在迭代器中，然而这种处理方式优点与缺点并存：</strong></p>
<h3 id="迭代器的优点"><a href="#迭代器的优点" class="headerlink" title="迭代器的优点"></a>迭代器的优点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 为序列和非序列类型提供了一种统一的迭代取值方式</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 惰性计算：迭代器对象表示的是一个数据流，可以只在需要时才去调用<span class="built_in">next</span>来计算出一个值，就迭代器本身来说，同一时          刻在内存中只有一个值，因而可以存放无限大的数据流，而对于其他容器类型，如列表，需要把所有的元素都           存放于内存中，受内存大小的限制，可以存放的值的个数是有限的</span><br></pre></td></tr></table></figure>

<h3 id="迭代器的缺点"><a href="#迭代器的缺点" class="headerlink" title="迭代器的缺点"></a>迭代器的缺点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 除非取尽，否则无法获取迭代器的长度</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 只能取下一个值，不能回到开始，更像是<span class="string">&#x27;一次性的&#x27;</span>，迭代器产生后的唯一目标就是重复执行<span class="built_in">next</span>方法直到值取尽，否则就会停留在某个位置，等待下一次调用<span class="built_in">next</span>；若是要再次迭代同个对象，只能重新调用<span class="built_in">iter</span>方法去创建一个新的迭代器对象，如果有两个或者多个循环使用同一个迭代器，必然只会有一个循环能取到值</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/11/12/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="池劲涛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="池劲涛的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/12/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F/" class="post-title-link" itemprop="url">面向过程与函数式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-12 07:20:25" itemprop="dateCreated datePublished" datetime="2018-11-12T07:20:25+08:00">2018-11-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-12-01 12:22:34" itemprop="dateModified" datetime="2018-12-01T12:22:34+08:00">2018-12-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Python系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h1><ul>
<li>编程范式</li>
<li>面向过程</li>
<li>函数式</li>
</ul>
<h1 id="内容详解"><a href="#内容详解" class="headerlink" title="内容详解"></a>内容详解</h1><h2 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a>编程范式</h2><p><strong>很多初学者在了解了一门编程语言的基本语法和使用后，面对一个开发需求时，仍然会觉得无从下手，没有思路，本节主题’编程范式’正是为了解决该问题，那么到底什么是编程范式呢</strong></p>
<p><strong>编程范式指的就是编程的套路，打个比方：如果把编程的过程比喻为练习武功，那编程范式指的就是武林中的各种流派，而在编程的世界里常见的流派有：面向过程，函数式，面向对象…</strong></p>
<p><strong>强调：’功夫的流派没有高低之分，只有习武的人才有高低之分’，在编程世界里更是这样，各种编程范式在不同的场景下都各有优劣，谁好谁坏不能一概而论</strong></p>
<h2 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;面向过程&#x27;</span>核心是<span class="string">&#x27;过程&#x27;</span>二字，<span class="string">&#x27;过程&#x27;</span>指的是解决问题的步骤 ---&gt; 先干啥 在干啥...</span><br><span class="line"></span><br><span class="line">基于面向过程开发程序就好比在设计一条流水线，是一种机械式的思维方式，这正好契合计算机的运行原理：任何程序的执行最终都需要转换成cpu的指令流水按过程调度执行 ---&gt; 无论采用什么语言，无论依据何种编程范式设计出的程序，最终的执行都是过程式的</span><br><span class="line"></span><br><span class="line">详细的，若程序一开始是要着手解决一个大的问题，按照过程式的思路就是把这个大的问题分解成很多个小问题或子过程去实现，然后依次调用即可，这极大地降低了程序的复杂度。举例如下：</span><br><span class="line"></span><br><span class="line">• 写一个数据远程备份程序，分三步：本地数据打包，上传至云服务器，检测备份文件可用性</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一：基于本章所学，我们可以用函数去实现这一个个的步骤</span></span><br><span class="line"><span class="comment"># 1、本地数据打包</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_backup</span>(<span class="params">folder</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找到备份目录: %s&quot;</span> %folder)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;正在备份...&#x27;</span>)</span><br><span class="line">    zip_file=<span class="string">&#x27;/tmp/backup_%s.zip&#x27;</span> %time.strftime(<span class="string">&#x27;%Y%m%d&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;备份成功，备份文件为: %s&#x27;</span> %zip_file)</span><br><span class="line">    <span class="keyword">return</span> zip_file</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#2、上传至云服务器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cloud_upload</span>(<span class="params">file</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nconnecting cloud storage center...&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;cloud storage connected&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;upload [%s] to cloud...&quot;</span> %file)</span><br><span class="line">    link=<span class="string">&#x27;https://www.xxx.com/bak/%s&#x27;</span> %os.path.basename(file)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;close connection&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> link</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#3、检测备份文件可用性</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_backup_check</span>(<span class="params">link</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n下载文件: %s , 验证文件是否无损...&quot;</span> %link)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#二：依次调用</span></span><br><span class="line"><span class="comment"># 步骤一：本地数据打包</span></span><br><span class="line">zip_file = data_backup(<span class="string">r&quot;/Users/egon/欧美100G高清无码&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤二：上传至云服务器</span></span><br><span class="line">link=cloud_upload(zip_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤三：检测备份文件的可用性</span></span><br><span class="line">data_backup_check(link)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">面向过程总结：</span></span><br><span class="line"><span class="string">    1 优点：</span></span><br><span class="line"><span class="string">        将复杂的问题流程化，进而简单化</span></span><br><span class="line"><span class="string">    2 缺点：</span></span><br><span class="line"><span class="string">        程序的可扩展性极差，因为一套流水线或者流程就是用来解决一个问题的</span></span><br><span class="line"><span class="string">        就好比生产汽水的流水线无法生产汽车一样，即便是能，也得是大改，而且改一个组件，与其相关的组件可能都需要修改，比如我们修改了cloud_upload的逻辑，那么依赖其结果才能正常执行的data_backup_check也需要修改，这就造成了连锁反应，而且这一问题会随着程序规模的增大而变得越发的糟糕。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cloud_upload</span>(<span class="params">file</span>):</span> <span class="comment"># 加上异常处理，在出现异常的情况下，没有link返回</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\nconnecting cloud storage center...&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;cloud storage connected&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;upload [%s] to cloud...&quot;</span> %file)</span><br><span class="line">        link=<span class="string">&#x27;https://www.xxx.com/bak/%s&#x27;</span> %os.path.basename(file)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;close connection&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> link</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;upload error&#x27;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;close connection.....&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_backup_check</span>(<span class="params">link</span>):</span> <span class="comment"># 加上对参数link的判断</span></span><br><span class="line">    <span class="keyword">if</span> link:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n下载文件: %s , 验证文件是否无损...&quot;</span> %link)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\n链接不存在&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">3 应用场景：</span></span><br><span class="line"><span class="string">    面向过程的程序设计一般用于那些功能一旦实现之后就很少需要改变的场景， 如果你只是写一些简单的脚本，去做一些一次性任务，用面向过程去实现是极好的，但如果你要处理的任务是复杂的，且需要不断迭代和维护， 那还是用面向对象最为方便。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="函数式"><a href="#函数式" class="headerlink" title="函数式"></a>函数式</h2><p><strong>函数式编程并非用函数编程这么简单，而是将计算机的运算视为数学意义上的运算，比起面向过程，函数式更加注重的是执行结果而非执行的过程，代表语言有：Haskell、Erlang。而python并不是一门函数式编程语言，但是仍为我们提供了很多函数式编程好的特性，如lambda，map，reduce，filter</strong></p>
<h3 id="匿名函数与lambda"><a href="#匿名函数与lambda" class="headerlink" title="匿名函数与lambda"></a>匿名函数与lambda</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 使用<span class="function"><span class="keyword">def</span>关键字创建的是有名字的函数</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">2 使用<span class="title">lambda</span>关键字创建的则是没有名字的函数，即匿名函数</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">语法：</span></span><br><span class="line"><span class="function">    <span class="title">lambda</span> 参数1， 参数2，...：</span></span><br><span class="line"><span class="function">        <span class="title">expression</span></span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">举例</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># 1、定义</span></span><br><span class="line"><span class="function"><span class="title">lambda</span> <span class="title">x</span>,<span class="title">y</span>,<span class="title">z</span>:</span>x+y+z</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x,y,z</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x+y+z</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、调用</span></span><br><span class="line"><span class="comment"># 方式一：</span></span><br><span class="line">res=(<span class="keyword">lambda</span> x,y,z:x+y+z)(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二：</span></span><br><span class="line">func=<span class="keyword">lambda</span> x,y,z:x+y+z <span class="comment"># “匿名”的本质就是要没有名字，所以此处为匿名函数指定名字是没有意义的</span></span><br><span class="line">res=func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">匿名函数与有名函数有相同的作用域，但是匿名意味着引用计数为<span class="number">0</span>，使用一次就释放，所以匿名函数用于临时使用一次的场景，匿名函数通常与其他函数配合使用，我们以下述字典为例来介绍它</span><br><span class="line"></span><br><span class="line">salaries=&#123;</span><br><span class="line">    <span class="string">&#x27;siry&#x27;</span>:<span class="number">3000</span>,</span><br><span class="line">    <span class="string">&#x27;tom&#x27;</span>:<span class="number">7000</span>,</span><br><span class="line">    <span class="string">&#x27;lili&#x27;</span>:<span class="number">10000</span>,</span><br><span class="line">    <span class="string">&#x27;jack&#x27;</span>:<span class="number">2000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">要想取得薪水的最大值和最小值，我们可以使用内置函数<span class="built_in">max</span>和<span class="built_in">min</span>（为了方便开发，python解释器已经为我们定义好了一系列常用的功能，称之为内置的函数，我们只需要拿来使用即可）</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(salaries)</span><br><span class="line"><span class="string">&#x27;tom&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">min</span>(salaries)</span><br><span class="line"><span class="string">&#x27;jack&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">内置<span class="built_in">max</span>和<span class="built_in">min</span>都支持迭代器协议，工作原理都是迭代字典，取得是字典的键，因而比较的是键的最大和最小值，而我们想要的是比较值的最大值与最小值，于是做出如下改动</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数max会迭代字典salaries，每取出一个“人名”就会当做参数传给指定的匿名函数，然后将匿名函数的返回值当做比较依据，最终返回薪资最高的那个人的名字</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">max</span>(salaries,key=<span class="keyword">lambda</span> k:salaries[k]) </span><br><span class="line"><span class="string">&#x27;lili&#x27;</span></span><br><span class="line"><span class="comment"># 原理同上</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">min</span>(salaries,key=<span class="keyword">lambda</span> k:salaries[k])</span><br><span class="line"><span class="string">&#x27;jack&#x27;</span></span><br><span class="line">同理，我们直接对字典进行排序，默认也是按照字典的键去排序的</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(salaries)</span><br><span class="line">[<span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;lili&#x27;</span>, <span class="string">&#x27;siry&#x27;</span>, <span class="string">&#x27;tom&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="map、reduce、filter"><a href="#map、reduce、filter" class="headerlink" title="map、reduce、filter"></a>map、reduce、filter</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">函数<span class="built_in">map</span>、reduce、<span class="built_in">filter</span>都支持迭代器协议，用来处理可迭代对象，我们以一个可迭代对象array为例来介绍它们三个的用法</span><br><span class="line"></span><br><span class="line">array=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">要求一：对array的每个元素做平方处理，可以使用<span class="built_in">map</span>函数</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>函数可以接收两个参数，一个是函数，另外一个是可迭代对象，具体用法如下</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res=<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x**<span class="number">2</span>,array)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line">&lt;<span class="built_in">map</span> <span class="built_in">object</span> at <span class="number">0x1033f45f8</span>&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">解析：<span class="built_in">map</span>会依次迭代array，得到的值依次传给匿名函数（也可以是有名函数），而<span class="built_in">map</span>函数得到的结果仍然是迭代器。</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(res) <span class="comment">#使用list可以依次迭代res，取得的值作为列表元素</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">要求二：对array进行合并操作，比如求和运算，这就用到了reduce函数</span><br><span class="line"></span><br><span class="line">reduce函数可以接收三个参数，一个是函数，第二个是可迭代对象，第三个是初始值</span><br><span class="line"></span><br><span class="line"><span class="comment"># reduce在python2中是内置函数，在python3中则被集成到模块functools中，需要导入才能使用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res=reduce(<span class="keyword">lambda</span> x,y:x+y,array)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">解析：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> 没有初始值，reduce函数会先迭代一次array得到的值作为初始值，作为第一个值数传给x，然后继续迭代一次array得到的值作为第二个值传给y，运算的结果为<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 将上一次reduce运算的结果作为第一个值传给x，然后迭代一次array得到的结果作为第二个值传给y，依次类推，知道迭代完array的所有元素，得到最终的结果<span class="number">15</span></span><br><span class="line"></span><br><span class="line">也可以为reduce指定初始值</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res=reduce(<span class="keyword">lambda</span> x,y:x+y,array,<span class="number">100</span>)•&gt;&gt;&gt; res</span><br><span class="line"><span class="number">115</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">要求三：对array进行过滤操作，这就用到了<span class="built_in">filter</span>函数，比如过滤出大于<span class="number">3</span>的元素</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res=<span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x&gt;<span class="number">3</span>,array)</span><br><span class="line">解析：<span class="built_in">filter</span>函数会依次迭代array，得到的值依次传给匿名函数，如果匿名函数的返回值为真，则过滤出该元素，而<span class="built_in">filter</span>函数得到的结果仍然是迭代器。</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(res) </span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">提示：我们介绍map、filter、reduce只是为了带大家了解函数式编程的大致思想，在实际开发中，我们完全可以用列表生成式或者生成器表达式来实现三者的功能。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span> </span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/11/12/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="池劲涛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="池劲涛的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/12/%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">面对对象编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-12 07:20:25" itemprop="dateCreated datePublished" datetime="2018-11-12T07:20:25+08:00">2018-11-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-12-01 12:22:34" itemprop="dateModified" datetime="2018-12-01T12:22:34+08:00">2018-12-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Python系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h1><ul>
<li>对象的概念</li>
<li>类与对象</li>
<li>面对对象编程</li>
</ul>
<h1 id="内容详细"><a href="#内容详细" class="headerlink" title="内容详细"></a>内容详细</h1><h2 id="对象的概念"><a href="#对象的概念" class="headerlink" title="对象的概念"></a>对象的概念</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;面对对象&#x27;</span>的核心就是<span class="string">&#x27;对象&#x27;</span>二字，而对象的精髓在于<span class="string">&#x27;整合&#x27;</span></span><br><span class="line"></span><br><span class="line">所有的程序都是由<span class="string">&#x27;数据&#x27;</span> + <span class="string">&#x27;功能&#x27;</span>组成，因而编写程序的本质就是：定义出一系列的数据，然后定义出一系列的功能来对数据进行操作</span><br><span class="line"></span><br><span class="line">在学习<span class="string">&#x27;对象&#x27;</span>之前，程序中的数据与功能是分离开的，例如：</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据：name、age、sex</span></span><br><span class="line">name=<span class="string">&#x27;lili&#x27;</span></span><br><span class="line">age=<span class="number">18</span></span><br><span class="line">sex=<span class="string">&#x27;female&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 功能：tell_info</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tell_info</span>(<span class="params">name,age,sex</span>):</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&lt;%s:%s:%s&gt;&#x27;</span> %(name,age,sex))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时若想执行查看个人信息的功能，需要同时拿来两样东西，一类是功能tell_info，另外一类则是多个数据name、age、sex，然后才能执行，非常麻烦</span></span><br><span class="line">tell_info(name,age,sex)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">========================================================================================</span><br><span class="line"></span><br><span class="line">在学习了<span class="string">&#x27;对象&#x27;</span>之后，我们就有了一个容器，该容器可以盛放数据与功能，所以我们可以说：对象是把数据与功能整合到一起的产物，或者说<span class="string">&#x27;对象&#x27;</span>就是一个盛放数据与功能的容器</span><br><span class="line"></span><br><span class="line">如果：</span><br><span class="line">     把<span class="string">&#x27;数据&#x27;</span>比喻为<span class="string">&#x27;睫毛膏&#x27;</span>、<span class="string">&#x27;眼影&#x27;</span>、<span class="string">&#x27;唇彩&#x27;</span>等化妆所需要的原材料</span><br><span class="line">     把<span class="string">&#x27;功能&#x27;</span>比喻为<span class="string">&#x27;眼线笔&#x27;</span>、<span class="string">&#x27;眉笔&#x27;</span>等化妆所需要的工具</span><br><span class="line">那么：</span><br><span class="line">     <span class="string">&#x27;对象&#x27;</span>就是一个<span class="string">&#x27;彩妆盒&#x27;</span>，<span class="string">&#x27;彩妆盒&#x27;</span>可以把<span class="string">&#x27;原材料&#x27;</span>与<span class="string">&#x27;工具&#x27;</span>都装到一起</span><br></pre></td></tr></table></figure>

<p><img src="https://pic2.zhimg.com/80/v2-0e2848da85da660b62cd804505d52095_720w.jpg" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果我们把<span class="string">&#x27;化妆&#x27;</span>比喻为要执行的业务逻辑，此时只需要拿来一样东西即可，那就是彩妆盒，因为彩妆盒里整合了<span class="string">&#x27;化妆&#x27;</span>所需的所有原材料与功能</span><br><span class="line"></span><br><span class="line">这比起分别拿来原材料与功能才能执行，要方便的多</span><br><span class="line"></span><br><span class="line">在了解了对象的基本概念之后，理解面向对象的编程方式就相对简单很多了，面向对象编程就是要造出一个个的对象，把原本分散开的相关数据<span class="string">&#x27;整合&#x27;</span>到一个个的对象里，这么做既方便使用，也可以提高程序的解耦合程度，进而提升了程序的可扩展性</span><br><span class="line"></span><br><span class="line">强调：软件质量属性包含很多方面，面向对象解决的仅仅是扩展性问题</span><br></pre></td></tr></table></figure>

<p><img src="https://pic1.zhimg.com/80/v2-be68cd9e27b83c937cf44dbe7a2cf56c_720w.jpg" alt="img"></p>
<h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类 ---&gt; 类别/种类：是免息那个对象分析和设计的基石</span><br><span class="line">如果多个对象有相似的数据与功能，那么该多个对象就属于同一种类</span><br><span class="line">有了类的好处：</span><br><span class="line">    可以把同一类的对象相同的数据与功能存放到类里，而无需每个对象都重复存一份，这样每个对象里只需存自己独有的数据即可，极大地节省了空间</span><br><span class="line">所以 ---&gt; 如果说对象是用来存放数据与功能的容器，那么类则是用来存放多个对象相同的数据与功能的容器</span><br></pre></td></tr></table></figure>

<p><img src="https://pic2.zhimg.com/80/v2-0b1c2138d316307c0c830aa1df3aa1e1_720w.jpg" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">综上所述：</span><br><span class="line">    <span class="number">1</span> 虽然我们是先介绍对象，后介绍类，但是：<span class="string">&#x27;在程序中，必须要事先定义类，然后再调用类产生对象(调用类类拿到的返回值就是对象)&#x27;</span></span><br><span class="line">    <span class="number">2</span> 产生对象的类与对象之间存在关联，这种关联指的是：对象可以访问到类中共有的数据与功能，所以类中的内容仍然是属于对象的，类只不过是一种节省空间，减少代码冗余的机制，面对对象编程最终的核心仍然是去使用对象</span><br></pre></td></tr></table></figure>

<h2 id="面对对象编程"><a href="#面对对象编程" class="headerlink" title="面对对象编程"></a>面对对象编程</h2><h3 id="类的定义与实例化"><a href="#类的定义与实例化" class="headerlink" title="类的定义与实例化"></a>类的定义与实例化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">我们以开发一个清华大学的选课系统为例，来简单介绍基于面向对象的思想如何编写程序</span><br><span class="line"></span><br><span class="line">面向对象的基本思路就是把程序中要用到的、相关联的数据与功能整合到对象里，然后再去使用，但程序中要用到的数据以及功能那么多，如何找到相关连的呢？我需要先提取选课系统里的角色：学生、老师、课程等，然后显而易见的是：学生有学生相关的数据于功能，老师有老师相关的数据与功能，我们单以学生为例，</span><br><span class="line"></span><br><span class="line"><span class="comment"># 学生的数据有</span></span><br><span class="line">学校</span><br><span class="line">名字</span><br><span class="line">年龄</span><br><span class="line">性别</span><br><span class="line"></span><br><span class="line"><span class="comment"># 学生的功能有</span></span><br><span class="line">选课</span><br><span class="line">详细的</span><br><span class="line"></span><br><span class="line"><span class="comment"># 学生1：</span></span><br><span class="line">    数据:</span><br><span class="line">        学校=清华大学</span><br><span class="line">        姓名=李建刚</span><br><span class="line">        性别=男</span><br><span class="line">        年龄=<span class="number">28</span></span><br><span class="line">    功能：</span><br><span class="line">        选课</span><br><span class="line"></span><br><span class="line"><span class="comment"># 学生2：</span></span><br><span class="line">    数据:</span><br><span class="line">        学校=清华大学</span><br><span class="line">        姓名=王大力</span><br><span class="line">        性别=女</span><br><span class="line">        年龄=<span class="number">18</span></span><br><span class="line">    功能：</span><br><span class="line">        选课</span><br><span class="line"></span><br><span class="line"><span class="comment"># 学生3：</span></span><br><span class="line">    数据:</span><br><span class="line">        学校=清华大学</span><br><span class="line">        姓名=牛嗷嗷</span><br><span class="line">        性别=男</span><br><span class="line">        年龄=<span class="number">38</span></span><br><span class="line">    功能：</span><br><span class="line">        选课</span><br><span class="line">我们可以总结出一个学生类，用来存放学生们相同的数据与功能</span><br><span class="line"></span><br><span class="line"><span class="comment"># 学生类</span></span><br><span class="line">    相同的特征:</span><br><span class="line">        学校=清华大学</span><br><span class="line">    相同的功能：</span><br><span class="line">        选课</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">基于上述分析的结果，我们接下来需要做的就是在程序中定义出类，然后调用类产生对象</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="comment"># 类的命名应该使用“驼峰体”</span></span><br><span class="line"></span><br><span class="line">    school=<span class="string">&#x27;清华大学&#x27;</span> <span class="comment"># 数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose</span>(<span class="params">self</span>):</span> <span class="comment"># 功能</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is choosing a course&#x27;</span> %self.name)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类体最常见的是变量的定义和函数的定义，但其实类体可以包含任意Python代码，类体的代码在类定义阶段就会执行，因而会产生新的名称空间用来存放类中定义的名字，可以打印Student.__dict__来查看类这个容器内盛放的东西</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Student.__dict__)</span><br><span class="line">&#123;..., <span class="string">&#x27;school&#x27;</span>: <span class="string">&#x27;清华大学&#x27;</span>, <span class="string">&#x27;choose&#x27;</span>: &lt;function Student.choose at <span class="number">0x1018a2950</span>&gt;, ...&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">调用类的过程称为将类实例化，拿到的返回值就是程序中的对象，或称为一个实例</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stu1=Student() <span class="comment"># 每实例化一次Student类就得到一个学生对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stu2=Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stu3=Student()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">如此stu1、stu2、stu3全都一样了（只有类中共有的内容，而没有各自独有的数据），想在实例化的过程中就为三位学生定制各自独有的数据：姓名，性别，年龄，需要我们在类内部新增一个__init__方法,如下</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span></span><br><span class="line">    school=<span class="string">&#x27;清华大学&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#该方法会在对象产生之后自动执行，专门为对象进行初始化操作，可以有任意代码，但一定不能返回非None的值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,sex,age</span>):</span></span><br><span class="line">        self.name=name</span><br><span class="line">        self.sex=sex</span><br><span class="line">        self.age=age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose</span>(<span class="params">self</span>):</span> </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is choosing a course&#x27;</span> %self.name)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">然后我们重新实例出三位学生</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stu1=Student(<span class="string">&#x27;李建刚&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">28</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stu2=Student(<span class="string">&#x27;王大力&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">18</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stu3=Student(<span class="string">&#x27;牛嗷嗷&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">38</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">单拿stu1的产生过程来分析，调用类会先产生一个空对象stu1，然后将stu1连同调用类时括号内的参数一起传给Student.__init__(stu1,’李建刚’,’男’,<span class="number">28</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, sex, age</span>):</span></span><br><span class="line">    self.name = name  <span class="comment"># stu1.name = &#x27;李建刚&#x27;</span></span><br><span class="line">    self.sex = sex    <span class="comment"># stu1.sex = &#x27;男&#x27;</span></span><br><span class="line">    self.age = age    <span class="comment"># stu1.age = 28</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">会产生对象的名称空间，同样可以用__dict__查看</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stu1.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;李建刚&#x27;</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">28</span>&#125;</span><br></pre></td></tr></table></figure>

<p><strong>至此，我们造出了三个对象与一个类，对象存放各自独有的数据，类中存放对象们共有的内容</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-c3bb7aefce6ffee1029b1ae5dee72689_720w.jpg" alt="img"></p>
<p><strong>存的目的是为了用，那么如何访问对象或者类中存放的内容呢？</strong></p>
<h3 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="类属性与对象属性"><a href="#类属性与对象属性" class="headerlink" title="类属性与对象属性"></a>类属性与对象属性</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在类中定义的名字，都是类的属性，细说的话，类有两种属性：数据属性和函数属性，可以通过__dict__访问属性的值，比如Student.__dict__[‘school’]，但Python提供了专门的属性访问语法</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Student.school <span class="comment"># 访问数据属性，等同于Student.__dict__[&#x27;school&#x27;]</span></span><br><span class="line"><span class="string">&#x27;清华大学&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Student.choose <span class="comment"># 访问函数属性，等同于Student.__dict__[&#x27;choose&#x27;]</span></span><br><span class="line">&lt;function Student.choose at <span class="number">0x1018a2950</span>&gt;</span><br><span class="line"><span class="comment"># 除了查看属性外，我们还可以使用Student.attrib=value(修改或新增属性),用del Student.attrib删除属性。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">操作对象的属性也是一样</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stu1.name <span class="comment"># 查看，等同于obj1.__dict__[‘name&#x27;]</span></span><br><span class="line"><span class="string">&#x27;李建刚&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stu1.course=’python’ <span class="comment"># 新增，等同于obj1.__dict__[‘course&#x27;]=&#x27;python&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stu1.age=<span class="number">38</span> <span class="comment"># 修改，等同于obj1.__dict__[‘age&#x27;]=38</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> obj1.course <span class="comment"># 删除，等同于del obj1.__dict__[&#x27;course&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="属性查找与绑定方法"><a href="#属性查找与绑定方法" class="headerlink" title="属性查找与绑定方法"></a>属性查找与绑定方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">对象的名称空间里只存放着对象独有的属性，而对象们相似的属性是存放于类中的。对象在访问属性时，会优先从对象本身的__dict__中查找，未找到，则去类的__dict__中查找</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、类中定义的变量是类的数据属性，是共享给所有对象用的，指向相同的内存地址</span><br><span class="line"></span><br><span class="line"><span class="comment"># id都一样</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(Student.school)) <span class="comment"># 4301108704</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(stu1.school)) <span class="comment"># 4301108704</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(stu2.school)) <span class="comment"># 4301108704</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(stu3.school)) <span class="comment"># 4301108704</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2</span>、类中定义的函数是类的函数属性，类可以使用，但必须遵循函数的参数规则，有几个参数需要传几个参数</span><br><span class="line"></span><br><span class="line">Student.choose(stu1) <span class="comment"># 李建刚 is choosing a course</span></span><br><span class="line">Student.choose(stu2) <span class="comment"># 王大力 is choosing a course</span></span><br><span class="line">Student.choose(stu3) <span class="comment"># 牛嗷嗷 is choosing a course</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">但其实类中定义的函数主要是给对象使用的，而且是绑定给对象的，虽然所有对象指向的都是相同的功能，但是绑定到不同的对象就是不同的绑定方法，内存地址各不相同</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(Student.choose)) <span class="comment"># 4335426280</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(stu1.choose)) <span class="comment"># 4300433608</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(stu2.choose)) <span class="comment"># 4300433608</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(stu3.choose)) <span class="comment"># 4300433608</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">绑定到对象的方法特殊之处在于，绑定给谁就应该由谁来调用，谁来调用，就会将’谁’本身当做第一个参数自动传入（方法__init__也是一样的道理）</span><br><span class="line"></span><br><span class="line">stu1.choose()  <span class="comment"># 等同于Student.choose(stu1)</span></span><br><span class="line">stu2.choose()  <span class="comment"># 等同于Student.choose(stu2)</span></span><br><span class="line">stu3.choose()  <span class="comment"># 等同于Student.choose(stu3)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">绑定到不同对象的choose技能，虽然都是选课，但李建刚选的课，不会选给王大力，这正是”绑定“二字的精髓所在。</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意：绑定到对象方法的这种自动传值的特征，决定了在类中定义的函数都要默认写一个参数self，self可以是任意名字，但命名为self是约定俗成的。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python中一切皆为对象，且Python3中类与类型是一个概念，因而绑定方法我们早就接触过</span><br><span class="line"></span><br><span class="line"><span class="comment">#类型list就是类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">list</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#实例化的到3个对象<span class="title">l1</span>,<span class="title">l2</span>,<span class="title">l3</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">l1</span>=<span class="title">list</span>(<span class="params">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span>)</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">l2</span>=<span class="title">list</span>(<span class="params">[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span>)</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">l3</span>=<span class="title">list</span>(<span class="params">[<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>]</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#三个对象都有绑定方法<span class="title">append</span>,是相同的功能,但内存地址不同</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">l1</span>.<span class="title">append</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">built</span>-<span class="title">in</span> <span class="title">method</span> <span class="title">append</span> <span class="title">of</span> <span class="title">list</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x10b482b48</span>&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">l2</span>.<span class="title">append</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">built</span>-<span class="title">in</span> <span class="title">method</span> <span class="title">append</span> <span class="title">of</span> <span class="title">list</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x10b482b88</span>&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">l3</span>.<span class="title">append</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">built</span>-<span class="title">in</span> <span class="title">method</span> <span class="title">append</span> <span class="title">of</span> <span class="title">list</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x10b482bc8</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">#操作绑定方法<span class="title">l1</span>.<span class="title">append</span>(<span class="params"><span class="number">4</span></span>),就是在往<span class="title">l1</span>添加4,绝对不会将4添加到<span class="title">l2</span>或<span class="title">l3</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">l1</span>.<span class="title">append</span>(<span class="params"><span class="number">4</span></span>) #等同于<span class="title">list</span>.<span class="title">append</span>(<span class="params">l1,<span class="number">4</span></span>)</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">l1</span></span></span><br><span class="line"><span class="class">[1,2,3,4]</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">l2</span></span></span><br><span class="line"><span class="class">[&#x27;<span class="title">a</span>&#x27;,&#x27;<span class="title">b</span>&#x27;,&#x27;<span class="title">c</span>&#x27;]</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">l3</span></span></span><br><span class="line"><span class="class">[&#x27;<span class="title">x</span>&#x27;,&#x27;<span class="title">y</span>&#x27;]</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>在上述介绍类与对象的使用过程中，我们更多的是站在底层原理的角度去介绍类与对象之间的关联关系，如果只是站在使用的角度，我们无需考虑语法”对象.属性”中”属性”到底源自于哪里，只需要知道是通过对象获取到的就可以了，所以说，对象是一个高度整合的产物，有了对象，我们只需要使用”对象.xxx“的语法就可以得到跟这个对象相关的所有数据与功能，十分方便且解耦合程度极高。</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/11/12/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%97%AD%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="池劲涛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="池劲涛的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/11/12/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%97%AD%E5%8C%85/" class="post-title-link" itemprop="url">函数对象和闭包</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-11-12 07:20:25" itemprop="dateCreated datePublished" datetime="2018-11-12T07:20:25+08:00">2018-11-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-12-01 12:22:34" itemprop="dateModified" datetime="2018-12-01T12:22:34+08:00">2018-12-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Python%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Python系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h1><ul>
<li>函数对象</li>
<li>闭包函数</li>
</ul>
<h1 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h1><p><strong>函数对象指的是函数可以被当做 ‘数据’ 来处理，具体可以分为四个方面的使用</strong></p>
<h2 id="函数可以被引用"><a href="#函数可以被引用" class="headerlink" title="函数可以被引用"></a>函数可以被引用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">func = add</span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">&gt;&gt;&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="函数可以作为容器类型的元素"><a href="#函数可以作为容器类型的元素" class="headerlink" title="函数可以作为容器类型的元素"></a>函数可以作为容器类型的元素</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">&#x27;add&#x27;</span> : add, <span class="string">&#x27;max&#x27;</span> : <span class="built_in">max</span>&#125;</span><br><span class="line">dic</span><br><span class="line">&gt;&gt;&gt;&#123;<span class="string">&#x27;add&#x27;</span>: &lt;function add at <span class="number">0x100661e18</span>&gt;, <span class="string">&#x27;max&#x27;</span>: &lt;built-<span class="keyword">in</span> function <span class="built_in">max</span>&gt;&#125;</span><br><span class="line">dic[<span class="string">&#x27;add&#x27;</span>](<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="函数可以作为参数传入另一个函数"><a href="#函数可以作为参数传入另一个函数" class="headerlink" title="函数可以作为参数传入另一个函数"></a>函数可以作为参数传入另一个函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x,y,func</span>):</span></span><br><span class="line">    <span class="keyword">return</span> func(x,y)</span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,add)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="函数的返回值也可以是一个函数"><a href="#函数的返回值也可以是一个函数" class="headerlink" title="函数的返回值也可以是一个函数"></a>函数的返回值也可以是一个函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">    <span class="keyword">return</span> add</span><br><span class="line">func = bar()</span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h1 id="闭包函数"><a href="#闭包函数" class="headerlink" title="闭包函数"></a>闭包函数</h1><h2 id="闭与包"><a href="#闭与包" class="headerlink" title="闭与包"></a>闭与包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于函数对象的概念，我们可以将函数返回到任意位置去调用，但作用域的关系是在定义完函数时就已经被确定了的，与函数的调用位置无关</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span>():</span></span><br><span class="line">    x=<span class="number">3</span></span><br><span class="line">    f2=f1() <span class="comment">#调用f1()返回函数f2</span></span><br><span class="line">    f2() <span class="comment">#需要按照函数定义时的作用关系去执行，与调用位置无关</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">f3() <span class="comment">#结果为1    </span></span><br><span class="line"></span><br><span class="line">也就是说：函数被当做数据处理时，始终以<span class="string">&#x27;自带的作用域&#x27;</span>为准</span><br><span class="line"></span><br><span class="line">若内嵌函数包含对外部函数作用域(而非全局作用域)中变量的引用，那么该<span class="string">&#x27;内嵌函数&#x27;</span>就是<span class="string">&#x27;闭包函数&#x27;</span>，简称闭包</span><br><span class="line"></span><br><span class="line">x=<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>():</span></span><br><span class="line">    x=<span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(x)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">func=outer()</span><br><span class="line">func() <span class="comment"># 结果为2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以通过函数的closure属性，查看到闭包函数所包裹的外部变量</span><br><span class="line"></span><br><span class="line">func.__closure__</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(&lt;cell at <span class="number">0x10212af78</span>: <span class="built_in">int</span> <span class="built_in">object</span> at <span class="number">0x10028cca0</span>&gt;,)</span><br><span class="line">func.__closure__[<span class="number">0</span>].cell_contents</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&quot;闭&quot;</span>：代表函数是内部的</span><br><span class="line"><span class="string">&quot;包&quot;</span>：代表函数外<span class="string">&#x27;包裹&#x27;</span>着对外层作用域的引用</span><br><span class="line"></span><br><span class="line">所以 ---&gt; 无论在哪调用闭包函数，使用的仍然是包裹在其外层的变量</span><br></pre></td></tr></table></figure>

<h2 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">目前为止 我们得到了两种为函数体传值的方式</span><br><span class="line"><span class="comment"># 1 ：直接将值以参数的形式传入</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 ：将值包给函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment">#方式一：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">return</span> requests.get(url).text</span><br><span class="line"></span><br><span class="line"><span class="comment">#方式二：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>():</span></span><br><span class="line">        <span class="keyword">return</span> requests.get(url).text</span><br><span class="line">    <span class="keyword">return</span> get</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">提示：requests模块是用来模拟浏览器向网站发送请求并将页面内容下载到本地，需要事先安装：pip3 install requests</span><br><span class="line"></span><br><span class="line">对比两种方式：</span><br><span class="line"><span class="comment"># 方式一：在下载同一页面时需要重复传入url</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二：只需要传一次值，就会得到一个包含指定url的闭包函数，以后调用该闭包函数则无需再传url</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式一下载同一页面</span></span><br><span class="line">get(<span class="string">&#x27;https://www.python.org&#x27;</span>)</span><br><span class="line">get(<span class="string">&#x27;https://www.python.org&#x27;</span>)</span><br><span class="line">get(<span class="string">&#x27;https://www.python.org&#x27;</span>)</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 方式二下载同一页面</span></span><br><span class="line">python=page(<span class="string">&#x27;https://www.python.org&#x27;</span>)</span><br><span class="line">python()</span><br><span class="line">python()</span><br><span class="line">python()</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p><strong>闭包函数的这种特性有时又称为惰性计算。使用将值包给函数的方式，在接下来的装饰器中也将大有用处</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">池劲涛</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
